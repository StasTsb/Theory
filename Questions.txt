79. Толстый и тонкий клиент
-------------------------------------------------------------------------------------------------------------------------
Толстый - выполняет основные манипуляции на своей стороне, сервер в свою очередь 
выступает как хранилище информации (1C, online games)

Тонкий - переносит выполнение задач на сервер, не применяя свои мощности. (browser)

78. Что такое куки (cookies)? Как их тестировать?
-------------------------------------------------------------------------------------------------------------------------
Файл cookie HTTP (файл cookie Интернета, файл cookie браузера) представляет собой небольшой фрагмент данных 
(часть http заголовка), который веб-сервер хранит в текстовом файле на жестком диске пользователя (клиента). 
Эта часть информации затем отправляется обратно на сервер каждый раз, когда браузер запрашивает страницу с сервера. 
Обычно cookie-файлы содержат персонализированные пользовательские данные или информацию, которые используются для 
определения того, поступили ли два запроса от одного и того же браузера - например, для входа пользователя в 
систему или для связи между различными веб-страницами. Он запоминает информацию stateful для stateless протокола HTTP.

Куки в основном используются для трех целей: 
Управление сессиями: Логины, корзины покупок, результаты игр и все, что сервер должен запомнить 
Пользовательские настройки, темы и другие настройки 
Запись и анализ поведения пользователя
Куки состоят в основном из трех вещей: 
Имя сервера, с которого был отправлен куки 
Время жизни (Cookies Lifetime)
Случайно сгенерированный уникальный номер

Максимальный размер кук = 4 килобайт (4096 байт), в некоторых источниках 4093 байт 

Виды кук:
Сессионные cookie, также известные как временные cookie, существуют только во временной памяти, пока 
пользователь находится на странице веб-сайта. Браузеры обычно удаляют сессионные cookie после того, как 
пользователь закрывает окно браузер. В отличие от других типов cookie, сессионные cookie не имеют 
истечения срока действия, и поэтому браузеры понимают их как сессионные.
Вместо того, чтобы удаляться после закрытия браузера, как это делают сессионные cookie, постоянные 
cookie-файлы удаляются в определенную дату или через определенный промежуток времени. Это означает, 
что информация о cookie будет передаваться на сервер каждый раз, когда пользователь посещает веб-сайт, 
которому эти cookie принадлежат. По этой причине постоянные cookie иногда называются следящие cookie, 
поскольку они могут использоваться рекламодателями для записи о предпочтениях пользователя в течение 
длительного периода времени. Однако, они также могут использоваться и в «мирных» целях, например, 
чтобы избежать повторного ввода данных при каждом посещении сайта.
Обычно атрибут домена cookie совпадает с доменом, который отображается в адресной строке веб-браузера. 
Это называется первый файл cookie. Однако сторонний файл cookie принадлежит домену, отличному от того, 
который указан в адресной строке. Этот тип файлов cookie обычно появляется, когда веб-страницы содержат 
контент с внешних веб-сайтов, например, рекламные баннеры. Это открывает возможности для отслеживания 
истории посещений пользователя и часто используется рекламодателями для предоставления релевантной 
рекламы каждому пользователю.

Супер-cookie — это cookie-файл с источником домена верхнего уровня (например, .ru) или общедоступным 
суффиксом (например, .co.uk). Обычные cookie, напротив, имеют происхождение от конкретного доменного 
имени, например, example.com. Супер-cookie могут быть потенциальной проблемой безопасности и поэтому 
часто блокируются веб-браузерами. Если браузер разблокирует вредоносный веб-сайт, злоумышленник может 
установить супер-cookie и потенциально нарушить или выдать себя за законные запросы пользователей на 
другой веб-сайт, который использует тот же домен верхнего уровня или общедоступный суффикс, что и 
вредоносный веб-сайт. Например, супер-cookie с происхождением .com может злонамеренно повлиять на 
запрос к example.com, даже если файл cookie не был создан с сайта example.com. Это может быть использовано 
для подделки логинов или изменения информации пользователя.
Поскольку cookie можно очень легко удалить из браузера, программисты ищут способы идентифицировать 
пользователей даже после полной очистки истории браузера. Одним из таких решений являются зомби-cookie 
(или evercookie, или persistent cookie) — не удаляемые или трудно удаляемые cookie, которые можно 
восстановить в браузере с помощью JavaScript. Это возможно потому, что для хранения куков сайт 
одновременно использует все доступные хранилища браузера (HTTP ETag, Session Storage, Local Storage, 
Indexed DB), в том числе и хранилища приложений, таких как Flash Player (Local Shared Objects), 
Microsoft Silverlight (Isolated Storage) и Java (Java persistence API). Когда программа обнаруживает 
отсутствие в браузере cookie-файла, информация о котором присутствует в других хранилищах — она 
тут же восстанавливает его на место и, тем самым, идентифицирует пользователя для сайта.

Примеры Test case для Cookie testing:
-Отключение файлов cookie: отключите все файлы cookie и попытайтесь использовать основные функции сайта 
-Поврежденные файлы cookie: вручную отредактируйте файл cookie в блокноте и измените параметры на несколько случайных значений 
-Шифрование куки: конфиденциальная информация, такая как пароли и имена пользователей, должна быть зашифрована
-Тестирование файлов cookie в нескольких браузерах. Убедитесь, что с вашего веб-сайта правильно записываются cookie в разных браузерах 
-Проверка удаления куки с веб-сайта
-Удаление файлов cookie: удалите все файлы cookie для веб-сайтов и посмотрите, как веб-сайт среагирует 
-Доступ к файлам cookie: файлы cookie, написанные одним сайтом, не должны быть доступны другим 
-Тестирование с другими настройками. Тестирование должно выполняться правильно, чтобы убедиться, что веб-сайт 
работает хорошо с другими настройками файлов cookie. 
-Категоризируйте куки отдельно: куки не должны храниться в той же категории вирусов, спама или шпионских программ

78. Какие коды сервера кешируются
-------------------------------------------------------------------------------------------------------------------------
В соответствии с RFC 7231,следующие коды состояния HTTP определяются как кэшируемые , 
если иное не указано в определении метода или явных элементах управления кэшем :

200 OK
203 Неавторитетная Информация
204 Нет Контента
206 Частичное Содержание
300 Множественный выбор
301 Переехал На Постоянное место жительства
404 Не Найдено
405 Метод Не Допускается
410 Пропал
414 URI Слишком Долго
501 Не Реализовано

Кэш также зависит от метода HTTP:
Методы запроса могут быть определены как "cacheable", чтобы указать, что ответы на них могут 
быть сохранены для последующего повторного использования. В общем случае безопасные методы, 
которые не зависят от текущего или авторитетного ответа , определяются как кэшируемые; эта 
спецификация определяет GET , HEAD и POST как кэшируемые, хотя подавляющее большинство 
кэша реализации поддерживают только GET и HEAD .

Что касается метода POST , есть важная деталь:
Ответы на POST запросов могут быть кэшированы только в том случае, если они содержат 
явную информацию о свежести.

 Кэш может вычислить время жизни свежести (обозначается как
   freshness_lifetime) ответа, используя первое совпадение
   следующий:

   o Если кеш общий и директива ответа s-maxage
      ( Раздел 5.2.2.9 ) присутствует, используйте его значение или
   o Если присутствует директива ответа max-age ( раздел 5.2.2.8 ),
      использовать его значение, или
   o Если присутствует поле заголовка ответа Expires ( раздел 5.3 ), используйте
      его значение минус значение поля заголовка ответа Date, или
   o В противном случае в ответе не указано явное время истечения срока действия.
      Может быть применимо эвристическое время жизни свежести; видеть
      Раздел 4.2.2 .

   Обратите внимание, что этот расчет не подвержен перекосу часов, поскольку все
   Информация поступает с исходного сервера.
   https://datatracker.ietf.org/doc/html/rfc7234#section-4.2.1

77. Web-socket
-------------------------------------------------------------------------------------------------------------------------
- протокол связи поверх TCP-соединения, предназначенный для обмена сообщениями 
между браузером и веб-сервером в режиме реального времени.

Данные передаются по нему в обоих направлениях в виде «пакетов», без разрыва 
соединения и дополнительных HTTP-запросов.
WebSocket особенно хорош для сервисов, которые нуждаются в постоянном обмене 
данными, например онлайн игры, торговые площадки, работающие в реальном времени, и т.д.

Чтобы открыть веб-сокет-соединение, нам нужно создать объект new WebSocket, указав в 
url-адресе специальный протокол ws: let socket = new WebSocket("ws://javascript.info");

Также существует протокол wss://, использующий шифрование. Это как HTTPS для веб-сокетов.

Как только объект WebSocket создан, мы должны слушать его события. Их всего 4:
open – соединение установлено,
message – получены данные,
error – ошибка,
close – соединение закрыто.

А если мы хотим отправить что-нибудь, то вызов socket.send(data) сделает это.

Когда new WebSocket(url) создан, он тут же сам начинает устанавливать соединение.
Браузер, при помощи специальных заголовков, спрашивает сервер: «Ты поддерживаешь 
Websocket?» и если сервер отвечает «да», они начинают работать по протоколу WebSocket, 
который уже не является HTTP.

Пример заголовков для запроса, который делает new WebSocket("wss://javascript.info/chat")
GET /chat
Host: javascript.info
Origin: https://javascript.info
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==
Sec-WebSocket-Version: 13

Origin – источник текущей страницы (например https://javascript.info). Объект WebSocket 
по своей природе не завязан на текущий источник. Нет никаких специальных заголовков 
или других ограничений. Старые сервера все равно не могут работать с WebSocket, поэтому 
проблем с совместимостью нет. Но заголовок Origin важен, так как он позволяет серверу 
решать, использовать ли WebSocket с этим сайтом.
Connection: Upgrade – сигнализирует, что клиент хотел бы изменить протокол.
Upgrade: websocket – запрошен протокол «websocket».
Sec-WebSocket-Key – случайный ключ, созданный браузером для обеспечения безопасности.
Sec-WebSocket-Version – версия протокола WebSocket, текущая версия 13.

Могут быть дополнительные заголовки Sec-WebSocket-Extensions и Sec-WebSocket-Protocol, 
описывающие расширения и подпротоколы.

Поток данных в WebSocket состоит из «фреймов», фрагментов данных, которые могут быть 
отправлены любой стороной, и которые могут быть следующих видов:

«текстовые фреймы» – содержат текстовые данные, которые стороны отправляют друг другу.
«бинарные фреймы» – содержат бинарные данные, которые стороны отправляют друг другу.
«пинг-понг фреймы» используется для проверки соединения; отправляется с сервера, браузер 
реагирует на них автоматически.
также есть «фрейм закрытия соединения» и некоторые другие служебные фреймы.

Обычно, когда сторона хочет закрыть соединение (браузер и сервер имеют равные права), они 
отправляют «фрейм закрытия соединения» с кодом закрытия и указывают причину в виде текста.

Метод для этого:
socket.close([code], [reason]);

code – специальный WebSocket-код закрытия (не обязателен).
reason – строка с описанием причины закрытия (не обязательна).

Затем противоположная сторона в обработчике события close получит и код code и причину 
reason, например:

// закрывающая сторона:
socket.close(1000, "работа закончена");
// другая сторона:
socket.onclose = event => {
  // event.code === 1000
  // event.reason === "работа закончена"
  // event.wasClean === true (закрыто чисто)
};

code – это не любое число, а специальный код закрытия WebSocket.
Наиболее распространённые значения:

1000 – по умолчанию, нормальное закрытие,
1006 – невозможно установить такой код вручную, указывает, что соединение было 
потеряно (нет фрейма закрытия).
1001 – сторона отключилась, например сервер выключен или пользователь покинул страницу,
1009 – сообщение слишком большое для обработки,
1011 – непредвиденная ошибка на сервере,
…и так далее.

Состояние соединения
Чтобы получить состояние соединения, существует дополнительное свойство 
socket.readyState со значениями:
0 – «CONNECTING»: соединение ещё не установлено,
1 – «OPEN»: обмен данными,
2 – «CLOSING»: соединение закрывается,
3 – «CLOSED»: соединение закрыто.

76. Архитектура приложений (монолитная, микросервисная)
-------------------------------------------------------------------------------------------------------------------------
Архивный пакет (например, формат war) содержит приложения со всеми функциями приложения, 
обычно мы называем его одним приложением. Методология построения монолитных приложений 
называется архитектурой монолитных приложений.

https://russianblogs.com/article/16941516187/

75. Уровни домена
-------------------------------------------------------------------------------------------------------------------------
Домен – это адрес сайта или название зоны. Все компьютеры определяются в сети при 
помощи IP-адреса в виде последовательности чисел.

Доменное имя может состоять из последовательности латинских букв или содержать 
цифры, кириллицу и знак дефиса. Дефис должен находиться только в середине 
последовательности. Буквы прописные или строчные, регистр значения не имеет.

Домены разделяют на первого (верхнего), второго и третьего уровня. При этом если разобрать 
состав доменного имени, то  считывание доменов идет справа налево.

Домены первого уровня:
Такие домены нельзя купить. Они регистрируются и предоставляются для использования 
организацией ICANN. Постоянно возникают новые доменные зоны, например .travel

Доменные зоны предоставляются странам:
.ru – России;
.de – Германии;
.kz – Казахстан.

Или обозначают тип организации, использующей домен:
.com – для коммерческих организаций.
.info – информационные сайты.
.edu – для учебных заведений.

Домены второго уровня
Домены регистрируют в одной из зон первого уровня (страновые или международные домены). 
От доменной зоны отделяются точкой. Имя должно быть уникальным в пределах одной зоны. 
Право владения выдается на год, затем нужно продлевать его за отдельную плату.

Домены третьего уровня
Распространенные домены третьего уровня – относятся к географическим региональным 
доменам. Например .msk.ru, .perm.ru. Такой домен полезен для местных сайтов, например 
новостных или городского портала.

Домены третьего уровня не привязанные к гео-зонам вроде .msk.ru, spb.ru называются еще 
субдоменами или поддоменами. Регистрируются у организаций, которые владеют доменами 
второго уровня. В одном таком домене может быть неограниченное число доменов третьего. 
Пользователь может настроить поддомен в панели управления хостингом.

Пример:
(3)forum.(2)house.(1)info

74. URL, URA, URN, URI
-------------------------------------------------------------------------------------------------------------------------
>URI (Uniform Resource Identifier) – это строка символов, которая используется для идентификации 
какого-либо ресурса по его адресу или по его имени, либо по тому и тому вместе.

Пример:
У человека есть имя, например Боб. Также у человека есть адрес проживания, например, пр. Победы 152. 
Предположим, нам нужно найти человека. Мы можем это сделать, начав поиск только по имени, или 
только по адресу, или по имени и адресу вместе.
Возвращаясь обратно к терминологии, вместо человека выступает какой-нибудь ресурс на сервере, и при 
помощи URI мы можем идентифицировать ресурс на сервере по его адресу или по его названию, 
либо по тому и тому вместе.

URI является либо URL, либо URN, либо одновременно обоими.
URL — это URI, который, помимо идентификации ресурса, предоставляет ещё и информацию о 
местонахождении этого ресурса. А URN — это URI, который только идентифицирует ресурс в определённом 
пространстве имён (и, соответственно, в определённом контексте), но не указывает его местонахождение. 
Например, URN urn:ISBN:0-395-36341-1 — это URI, который указывает на ресурс (книгу) 0-395-36341-1 в 
пространстве имён ISBN, но, в отличие от URL, URN не указывает на местонахождение этого ресурса: в нём 
не сказано, в каком магазине её можно купить или на каком сайте скачать. 

>URL (Uniform Resource Locator) – это строка символов, которая используется для идентификации 
какого-либо ресурса, но только по его адресу, по его местоположению.
В примере:
Уэе будет только адресс, Победы 152

URL чаще всего используется в Интернете для поиска ресурсов на сервере. URL буквально точно 
показывает нам, как определить ресурс, именно по его адресу.
Любой URL состоит из нескольких компонентов. Протокол и хост являются обязательными, все 
остальные - нет.

(1)https://(2)www.mysite.com:(3)80/(4)catalog/product?(5)id=15&color=yellow#(6)price
1. Протокол (https,http,ftp)
2. Хост (ip 111.44.11.222)
3. Порт
4. URL-путь
5. Параметр запроса
6. Якорь

>URN (Uniform Resource Name) – это строка символов, которая используется для идентификации какого-
либо ресурса, но только по его имени.
Пример:
В нашем примере это выглядит так. Мы знаем этого человека, знаем, что его зовут Боб. Но мы не знаем, 
где он живет. Нам придется искать его только по имени.

URN служит для обозначения уникального имени ресурса, неважно, где этот ресурс располагается 
в данный момент времени или вообще. Такая природа URN (независимость от адреса) позволяет 
ресурсам перемещаться с одного места на другое. URN позволяет получить доступ к ресурсу по 
различным сетевым протоколам, обращаясь к одному и тому же имени.

(1)urn:(2)issn:(4)1082-9873
1.Схема
2.Пространство имен
3.Уникальный идентификатор ресурса

73. DNS
-------------------------------------------------------------------------------------------------------------------------
Принцип работы DNS похож на поиск и вызов контактов из телефонной книги смартфона. 
Ищем имя, нажимаем «позвонить», и телефон соединяет нас с нужным абонентом. Понятно, 
что смартфон в ходе звонка не использует само имя человека, вызов возможен только по 
номеру телефона. Если вы внесете имя без номера телефона, позвонить человеку не сможете.
Так и с сайтом. Каждому имени сайта соответствует набор цифр формата 000.000.000.000. 
Этот набор называется IP-адресом, примером реального IP-адреса является 192.168.0.154 или 
203.113.89.134. Когда пользователь вводит в адресной строке браузера имя сайта, например 
google.com, компьютер запрашивает IP-адрес этого сайта на специальном DNS-сервере и после 
получения корректного ответа открывает сам сайт.

DNS-сервер?
Это как раз и есть «книга контактов» интернета. DNS-сервер — это специализированный 
компьютер (или группа), который хранит IP-адреса сайтов. Последние, в свою очередь, 
привязаны к именам сайтов и обрабатывает запросы пользователя. В интернете много 
DNS-серверов, они есть у каждого провайдера и обслуживают их пользователей.

Основное предназначение DNS-серверов — хранение информации о доменах и ее предоставление 
по запросу пользователей, а также кэширование DNS-записей других серверов.

DNS-серверы верхнего уровня, которые содержат информацию о корневой DNS-зоне, называются 
корневыми. Этими серверами управляют разные операторы. Изначально корневые серверы 
находились в Северной Америке, но затем они появились и в других странах. Основных серверов — 13. 
Чтобы повысить устойчивость интернета в случае сбоев, были созданы запасные копии, реплики 
корневых серверов. Так, количество корневых серверов увеличилось с 13 до 123.

С определенным доменным именем может быть связано несколько ресурсов — сайт и почтовый сервер. 
У этих ресурсов вполне могут быть разные IP-адреса, что дает возможность повысить надежность и 
эффективность работы сайта или почтовой системы. Есть у сайтов и поддомены, IP-адреса которых 
тоже могут быть разными.

Вся эта информация о связи сайта, поддоменов, почтовой системы хранится в специальном файле на 
DNS-сервере. Его содержимое называется DNS-зона. Файл содержит следующие типы записей:

А — адрес веб-ресурса, который привязан к конкретному имени домена.
MX — адрес почтового сервера.
CNAME — чаще всего этот тип записи используется для подключения поддомена.
NS — адрес DNS-сервера, который отвечает за содержимое других ресурсных записей.
TXT — любая текстовая информация о доменном имени.
SPF — данные с указанием списка серверов, которые входят в список доверенных для отправки писем от имени указанного домена.
SOA — исходная запись зоны, в которой указаны сведения о сервере и которая содержит шаблонную информацию о доменном имени.

72. Single sign-on 
-------------------------------------------------------------------------------------------------------------------------
— метод аутентификации, который позволяет пользователям безопасно аутентифицироваться 
сразу в нескольких приложениях и сайтах, используя один набор учетных данных.

SSO базируется на настройке доверительных отношений между приложением, известным как 
провайдер услуг, и системой управления доступами, например, OneLogin. Такие доверительные 
отношения часто базируются на обмене сертификатом между системой управления доступами и 
провайдером услуг.

Порядок авторизации обычно выглядит следующим образом:

-Пользователь заходит в приложение или на сайт, доступ к которому он хочет получить, 
то есть к провайдеру услуг.
-Провайдер услуг отправляет токен, содержащий информацию о пользователе (такую как email 
адрес) системе SSO (так же известной, как система управления доступами), как часть запроса 
на аутентификацию пользователя.
-В первую очередь система управления доступами проверяет был ли пользователь аутентифицирован 
до этого момента. Если да, она предоставляет пользователю доступ к приложению провайдера услуг, 
сразу приступая к шагу 5.
-Если пользователь не авторизовался, ему будет необходимо это сделать, предоставив идентификационные 
данные, требуемые системой управления доступами. Это может быть просто логин и пароль или же другие 
виды аутентификации, например одноразовый пароль (OTP — One-Time Password).
-Как только система управления доступами одобрит идентификационные данные, она вернет токен 
провайдеру услуг, подтверждая успешную аутентификацию.
-Этот токен проходит “сквозь браузер” пользователя провайдеру услуг.
-Токен, полученный провайдером услуг, подтверждается согласно доверительным отношениям, 
установленным между провайдером услуг и системой управления доступами во время 
первоначальной настройки.
-Пользователю предоставляется доступ к провайдеру услуг.

71. Двухфакторная аутентификация
-------------------------------------------------------------------------------------------------------------------------
Многофакторная аутентификация представляет собой метод, при котором пользователю для 
доступа к учетной записи или подтверждения операции с денежными средствами необходимо 
двумя различными факторами доказать, что именно он владелец учетной записи или что 
именно он осуществляет вход.

Доступ к ресурсам через ввод логина и пароля, является однофакторной аутентификацией, 
поскольку для входа используется только один тип аутентификационных данных 

Благодаря тому, что смартфоны стали неотъемлемой частью жизни, именно они стали 
одним из способов подтверждения личности пользователя. Они являются токенами для доступа 
к различным ресурсам. В этом случае одноразовый пароль генерируется или с помощью 
специального приложения, или приходит по SMS – это максимально простой для пользователя метод.

утентификация происходит следующим образом:
Пользователь вводит логин и пароль, указанные при регистрации. Если данная пара корректна 
(логин есть в базе и соответствует паролю) система высылает одноразовый пароль, имеющий 
ограниченное время действия.
Пользователь вводит одноразовый пароль и, если он совпадает с тем, что отправила система, то 
пользователь получает доступ к своей учетной записи, денежным средствам или подтверждает 
денежный перевод.

70. Идентификация, авторизация отличие от аутентификации
-------------------------------------------------------------------------------------------------------------------------
>Идентификация — процесс распознавания пользователя по его идентификатору.
Находясь на сайте банка, пользователь решает зайти в личный кабинет, чтобы сделать 
денежный перевод. На странице личного кабинета система вначале просит ввести 
идентификатор. Это может быть логин, имя и фамилия, адрес электронной почты или 
номер мобильного телефона.

После идентификации следует процесс аутентификации, в котором пользователю нужно доказать, 
что он является человеком, который регистрировался под именем Александр Петров.
Для доказательства необходимо:
-Нечто, присущее только пользователю. Биометрические данные: сканеры лица, отпечатки 
пальцев или сетчатки глаза.
-Нечто, известное только пользователю. Сюда относятся pin-коды, пароли, графические ключи, 
секретные слова.
-Нечто, имеющееся у пользователя. В данном качестве может выступать токен, то есть компактное 
устройство, предназначенное для обеспечения информационной безопасности пользователя,

>Аутентификация — процедура проверки подлинности, доказательство что пользователь 
именно тот, за кого себя выдает.
Самый распространенный тип аутентификационных данных – это пароль.
После ввода пользователем пароля система проверяет: соответствует ли условный пароль «Qwe123» 
пользователю с именем Александр Петров.

>Авторизация — предоставление определённых прав.
Если все верно, и пара логин-пароль верны, то система предоставит пользователю доступ к его 
ресурсам и совершение банковских операций, то есть произойдет авторизация.

69. XML, JSON
-------------------------------------------------------------------------------------------------------------------------
это два основных формата передачи данных

XML - eXtensible Markup Language — «расширяемый язык разметки» (язык описания данных)
(расширяемый - приспособлен для создания новых версий объектов и файлов)

Отличие от HTML?
(HTML — для разметки веб-страниц\ XML — для хранения и передачи информации(формат 
не содержит никаких указаний на то, как эти данные нужно отображать)
(Теги HTML являются заранее заданными)
(XML не использует заранее заданные теги. Можно давать тегам любые названия, какие 
захочешь — <header>, <title>) 

JSON (англ. JavaScript Object Notation) — текстовый формат обмена данными, основанный 
на JavaScript. Но при этом формат независим от JS и может использоваться в любом языке 
программирования.

В качестве значений в JSON могут быть использованы:

>>JSON-объект
 — это неупорядоченное множество пар «ключ:значение».
{
  "query": "Виктор Иван",
  "count": 7
}
"query"-ключ (название параметра, свойство обьекта)
"Виктор Иван" - значение

Пары «ключ-значение» разделены запятыми
Строки берем в кавычки, числа нет
Ключ — ВСЕГДА строка, но мы все равно берем его в кавычки. 
В JavaScript этого можно не делать, в JSON нельзя.
Писать ключи можно в любом порядке. Ведь JSON-объект — это 
неупорядоченное множество пар «ключ:значение».

>>Массив
Массив заключен в квадратные скобки []
[ "MALE", "FEMALE" ]
Внутри квадратных скобок идет набор значений. Тут нет ключей, как в объекте, 
поэтому обращаться к массиву можно только по номеру элемента.
Внутри массива может быть все:
Цифры, строки, смесь, обьекты

>>Число (целое или вещественное)
>>Литералы true/ false и null

Различия:

XML — используется в SOAP (всегда) и REST-запросах (реже);
JSON — используется в REST-запросах

XML:
<req>
	<surname>Иванов</surname>
	<name>Иван</name>
	<patronymic>Иванович</patronymic>
	<birthdate>01.01.1990</birthdate>
</req>
JSON:
{
	"surname": "Иванов",
	"name": "Иван",
	"patronymic": "Иванович",
	"birthdate": "01.01.1990"
}
За счет того, что мы не дублируем название поля каждый раз «surname – surname», 
читать JSON проще. И за счет этого же запрос меньше весит, что при плохом 
интернете бывает важно. Или при большой нагрузке.
https://habr.com/ru/post/554274/

68. WSDL
-------------------------------------------------------------------------------------------------------------------------
-Язык описания веб-сервисов. Это стандартный формат для описания веб-службы.
-WSDL — это основанный на XML протокол для обмена информацией в децентрализованных 
и распределенных средах.
-WSDL — это язык для описания взаимодействия с сервисами на основе XML.
https://coderlessons.com/tutorials/xml-tekhnologii/uznaite-wsdl/wsdl-kratkoe-rukovodstvo

67. Rest, Soap
-------------------------------------------------------------------------------------------------------------------------
REST — это архитектурный стиль. 
SOAP — это формат обмена сообщениями.

Пример реализации RESTful: JSON через HTTP
Пример реализации SOAP: XML поверх SOAP через HTTP

На верхнем уровне SOAP ограничивает структуры сообщений, тогда как REST 
это архитектурный подход, ориентированный на использование HTTP в качестве 
транспортного протокола.

66. Эстимация
-------------------------------------------------------------------------------------------------------------------------
Оценка определяет, сколько денег, усилий, ресурсов и времени потребуется для 
создания конкретной системы или продукта.

Цели:
-определение сроков
-оплата (fixed price/ time and material)
-оптимизация работы

Методы:
- Декомпозиция
(процесс разбеения на более мелкие части\модули\фичи\таски)- на основании можем 
проведение оценку трудозатрат.
- Based on Development (разраб. посчитали сколько потреб., количество 
часов умножаем на 30% либо на 50%) на одного разработчика несколько тестеров.
- По трем точкам (три временные точки- оптимистический вариант, оптимальный вариант,
писсимистичный вариант) 
- На основе опыта
- Пальцем в небо
- Метод процентного распределения (на каждый из этапов закладывается процентное время 
разработка 30% тестирование 20% сбор 10%)

65. Токен 
https://habr.com/ru/post/533868/
-------------------------------------------------------------------------------------------------------------------------
— средство идентификации пользователя или отдельного сеанса работы в 
компьютерных сетях и приложениях. Различают программные и аппаратные токены.

Программный токен обычно представляет собой зашифрованную последовательность 
символов, которая позволяет точно идентифицировать объект и определить уровень 
его привилегий. Он генерируется системой авторизации и привязывается к конкретному 
сеансу работы, клиенту сети или пакету данных.

Аппаратный токен — это устройство, хранящее уникальный пароль или способное 
генерировать его по определенным правилам. Для аутентификации аппаратный токен 
можно физически подключить к компьютеру через коммуникационный порт или 
специальный считыватель. Самые простые аппаратные токены просто выводят 
уникальный пароль для текущего сеанса на встроенный дисплей.

64. Реляционные базы данных и нереляционные
-------------------------------------------------------------------------------------------------------------------------
Реляционные БД хранят структурированные данные, которые обычно представляют 
объекты реального мира (сведения о человеке, или о содержимом корзины для товаров 
в магазине, сгруппированные в таблицах, формат которых задан на этапе 
проектирования хранилища.

Нереляционные БД хранят информацию в виде иерархических структур данных. 
Речь может идти об объектах с произвольным набором атрибутов. 
То, что в реляционной БД будет разбито на несколько взаимосвязанных таблиц, 
в нереляционной может храниться в виде целостной сущности.

-Структура и тип хранящихся данных: 
SQL/реляционные базы данных требуют наличия однозначно определённой 
структуры хранения данных, а NoSQL базы данных таких ограничений не ставят.

-Запросы: 
вне зависимости от лицензии, РСУБД реализуют SQL-стандарты, поэтому 
из них можно получать данные при помощи языка SQL. 
Каждая NoSQL база данных реализует свой способ работы с данными.

-Надёжность: 
когда речь заходит о надёжности, SQL базы данных - надежней.

-Поддержка: 
РСУБД популярны, и поэтому легко получить поддержку. 

-Хранение и доступ к сложным структурам данных: 
реляционные базы данных предполагают работу с сложными ситуациями, 
превосходят NoSQL-решения.

63. Уровни требований
-------------------------------------------------------------------------------------------------------------------------
-Пользовательские требования
 (описывают задачи, которые пользователь может выполнять с помощью 
разрабатываемого продукта, а также способы (сценарии) их решения в системе 
 (реакция продукта на действия пользователя, сценарии работы пользователя).

-Бизнес требования 
 (то как мы заработаем на продукте)

-Продуктные требования
*Функциональные требования (Functional Requirements) — охватывают 
предполагаемое поведение системы, определяя действия, которые система 
способна выполнять. Описывается в системной спецификации. 
В основном влияют на дизайн системы.
*Нефункциональные требования (Non-functional Requirements) 
—  охватывают свойства системы (удобства использования, надежность, 
масштабируемость), которыми она должна обладать при реализации своего поведения.

62. TCPandUDP
-------------------------------------------------------------------------------------------------------------------------
TCP – транспортный протокол передачи данных в сетях TCP/IP, предварительно 
устанавливающий соединение с сетью.
UDP – транспортный протокол, передающий сообщения-датаграммы без необходимости 
установки соединения в IP-сети.

Разница между протоколами TCP и UDP – в так называемой “гарантии доставки”. 
TCP требует отклика от клиента, которому доставлен пакет данных, подтверждения 
доставки, и для этого ему необходимо установленное заранее соединение. Также протокол 
TCP считается надежным, тогда как UDP получил даже именование “протокол 
ненадежных датаграмм. TCP исключает потери данных, дублирование и перемешивание 
пакетов, задержки. UDP все это допускает, и соединение для работы ему не требуется. 
Процессы, которым данные передаются по UDP, должны обходиться полученным, даже 
и с потерями. TCP контролирует загруженность соединения, UDP не контролирует ничего, 
кроме целостности полученных датаграмм.

С другой стороны, благодаря такой не избирательности и бесконтрольности, UDP доставляет 
пакеты данных (датаграммы) гораздо быстрее, потому для приложений, которые рассчитаны 
на широкую пропускную способность и быстрый обмен, UDP можно считать оптимальным 
протоколом. К таковым относятся сетевые и браузерные игры, а также программы просмотра 
потокового видео и приложения для видеосвязи (или голосовой): от потери пакета, полной 
или частичной, ничего не меняется, повторять запрос не обязательно, зато загрузка 
происходит намного быстрее. 

- TCP гарантирует доставку пакетов данных в неизменных виде, последовательности 
   и без потерь, UDP ничего не гарантирует.
- TCP нумерует пакеты при передаче, а UDP нет
- TCP работает в дуплексном режиме, в одном пакете можно отправлять информацию 
   и подтверждать получение предыдущего пакета.
- TCP требует заранее установленного соединения, UDP соединения не требует, у 
   него это просто поток данных.
- UDP обеспечивает более высокую скорость передачи данных.
- TCP надежнее и осуществляет контроль над процессом обмена данными.
- UDP предпочтительнее для программ, воспроизводящих потоковое видео, видеофонии 
   и телефонии, сетевых игр.
- UPD не содержит функций восстановления данных

61. CI&CD
-------------------------------------------------------------------------------------------------------------------------
Continuous Integration, (CI) Непрерывная интеграция — 
это методология разработки и набор практик, при которых в код вносятся небольшие 
изменения с частыми коммитами. 

Цель CI — обеспечить последовательный и автоматизированный способ сборки, упаковки 
и тестирования приложений. При налаженном процессе непрерывной интеграции разработчики 
с большей вероятностью будут делать частые коммиты, что, в свою очередь, будет способствовать 
улучшению коммуникации и повышению качества программного обеспечения.

Команды, внедряющие непрерывную интеграцию, часто начинают с настройки системы контроля версий 
и определения порядка работы. Несмотря на то что коммиты делаются часто, реализация фич и исправление 
багов могут выполняться довольно долго. Для контроля того, какие фичи и код готовы существует несколько подходов.

Многие используют фича-флаги (feature flag) — механизм для включения и выключения функционала в 
рантайме. Функционал, который еще находится в стадии разработки, оборачивается фича-флагами и развертывается 
из master-ветки в продакшн, но отключается до тех пор, пока не будет полностью готов к использованию. 

Другой способ работы с фичами — использование веток в системе контроля версий. В этом случае надо определить 
модель ветвления (например, такую как Gitflow) и описать как код попадает в ветки разработки, тестирования и продакшена. 
Для фич с длительным циклом разработки создаются отдельные фича-ветки. После завершения работы над фичей разработчики 
сливают изменения из фича-ветки в основную ветку разработки. Такой подход работает хорошо, но может быть неудобен, 
если одновременно разрабатывается много фич.

Большинство CI/CD-инструментов позволяет запускать сборку вручную, по коммиту или по расписанию. Командам необходимо 
обсудить расписание сборки, которое подходит для них в зависимости от численности команды, ожидаемого количества 
ежедневных коммитов и других критериев. Важно, чтобы коммиты и сборка были быстрыми, иначе долгая сборка может 
стать препятствием для разработчиков, пытающихся быстро и часто коммитить.

Continuous Delivery, (CD) Непрерывная поставка —
это автоматическое развертывание приложения в целевое окружение.
CD автоматически разворачивает приложения и выполняет дополнительные тесты.

60. Baseline and Benchmark
------------------------------------------------------------------------------------------------
Базовое тестирование — это процесс записи показателей производительности программного приложения при прохождении 
тестирования производительности. При обновление одного и того же приложения, включая программное обеспечение, 
аппаратное обеспечение, сеть и изменения кода, оно снова проходит тестирование производительности, и новые результаты 
метрик производительности сравниваются с предыдущими результатами метрик производительности. 
Показатели производительности от каждого теста хорошо документированы для будущих ссылок. Общая цель базового 
тестирования заключается в поддержании стабильного качества программного приложения.

Тестирование бенчмарка сравнивает результаты тестирования производительности с показателями производительности, 
согласованными в организации на основе различных отраслевых стандартов. Это помогает определить стандарты качества 
каждого программного приложения, принадлежавшего организации. Тестирование бенчмарка охватывает программное 
обеспечение, аппаратное обеспечение и производительность сети. Целью тестирования является тестирование всех текущих 
и будущих релизов приложения для поддержания высококачественных стандартов.

Различия:
Базовые метрики тестирования регистрируются после того, как приложения проходят тестирование производительности. 
Метрики тестирования часто заранее установлены для оценки производительности.

Базовое тестирование специфичен для отдельного программного приложения. 
Тестирование бенчмарков часто применимо ко всем программным приложениям, принадлежащим организации.

Базовое тестирование проводится с точки зрения приложения и пользовательского опыта. 
Тестирование бенчмарка проводится с точки зрения бизнеса 

59. Матрица трассировки
------------------------------------------------------------------------------------------------
— Метод визуализации связей между элементами системы в форме таблицы. Матрица трассировки создается путем 
связывания бизнес-требований с вариантами использования и сценариями тестирования, которые будут использоваться для их проверки.
Трассировка обеспечивает полноту тестирования и подготавливает основу для планирования тестов. 

Правила нумерации:
бизнес-требования: BR001, BR002
функциональные требования (вкл. нумерации для соответствующего бизнес-требования): FR001.01, FR001.02
технические спецификации: TS001.01.01, TS001.01.02, 

ID Матрицы  |  Бизнес-требования  |  Функциональные требования  |  Вариант использования  |   Сценарий тестирования   |     Комментарии

58. Мутационное тестирование 
------------------------------------------------------------------------------------------------
— это метод тестирования ПО, основанный на всевозможных изменениях исходного 
кода и проверке реакции на эти изменения набора автоматических тестов. Если тесты после изменения кода успешно 
выполняются, значит либо код не покрыт тестами, либо написанные тесты неэффективны. Критерий, определяющий 
эффективность набора автоматических тестов, называется Mutation Score Indicator (MSI).

57. Ramp тестирование
------------------------------------------------------------------------------------------------
Это метод тестирования, который предлагает ступенчато поднимать нагрузку до тех пор, пока система не выйдет из строя. 

56. Тестирование потоков
 ------------------------------------------------------------------------------------------------
Определяется как тип тестирования программного обеспечения, который проверяет основные функциональные возможности 
конкретной задачи (потока). Обычно проводится на ранней стадии фазы интеграционного тестирования. 

Тестирование на основе потоков подразделяется на две категории:
Однопоточное тестирование включает одну транзакцию приложения за раз 
Многопоточное тестирование включает одновременно несколько активных транзакций

Как производить:
>Тестирование на основе потоков является обобщенной формой тестирования на основе сеансов (session-based testing), 
в котором сеансы являются формой потока, но поток не обязательно является сеансом. 
>Для тестирования потока, поток или программа (небольшая функциональность) интегрируются и тестируются постепенно 
как подсистема, а затем выполняются для всей системы. 
>На самом низком уровне оно предоставляет интеграторам лучшее представление о том, что тестировать. 
Вместо непосредственного тестирования программных компонентов требуется, чтобы интеграторы сосредоточились на 
тестировании логических путей выполнения в контексте всей системы.

55.Конфигурационное тестирование
------------------------------------------------------------------------------------------------
Конфигурационное тестирование (Configuration testing) — специальный вид тестирования, направленный на проверку работы 
ПО при различных аппаратных и программных конфигурациях системы (заявленных платформах, поддерживаемых драйверах, при 
различных конфигурациях компьютеров и т. д. ) 

В зависимости от типа проекта конфигурационное тестирование может иметь разные цели:
>Проект по профилированию работы системы 
Цель Тестирования: определить оптимальную конфигурацию оборудования, обеспечивающую требуемые характеристики 
производительности и времени реакции тестируемой системы.

>Проект по миграции системы с одной платформы на другую 
Цель Тестирования: Проверить объект тестирования на совместимость с объявленным в спецификации оборудованием, 
операционными системами и программными продуктами третьих фирм.
Для клиент-серверных приложений конфигурационное тестирование можно условно разделить на два уровня 
(для некоторых типов приложений может быть актуален только один):

>Серверный
>Клиентский

54. Тестирование безопасности
------------------------------------------------------------------------------------------------
Это тип тестирования ПО, который выявляет уязвимости, угрозы и риски. 
Целью тестов безопасности является выявление всех возможных лазеек и слабых мест в ПО, 
которые могут привести к потере информации, доходов, репутации компании, 
сотрудников или клиентов. Общая стратегия безопасности основывается на трех основных принципах:

>Конфиденциальность - сокрытие определенных ресурсов или информации
>Целостность – ресурс может быть изменен только в соответствии с полномочиями пользователя
>Доступность - ресурсы должны быть доступны только авторизованному пользователю, внутреннему объекту или устройству

Тестирование безопасности обычно выполняет отдельный специалист по безопасности. 
В ходе тестирования безопасности испытатель производит следующие манипуляции: 

>попытки узнать пароль с помощью внешних средств;
>атака системы с помощью специальных утилит, анализирующих защиты;
>подавление, ошеломление системы (в надежде, что она откажется обслуживать других клиентов);
>целенаправленное введение ошибок в надежде проникнуть в систему в ходе восстановления;
>просмотр несекретных данных в надежде найти ключ для входа в систему.

Типы тестирования безопасности:
>Сканирование уязвимостей/оценка защищенности (Vulnerability Scanning) выполняется с помощью автоматизированного 
ПО для сканирования системы на наличие известных сигнатур уязвимостей. 

>Сканирование безопасности (Security Scanning) включает в себя выявление слабых сторон сети и системы, а затем 
предоставляет решения для снижения этих рисков. Это сканирование может быть выполнено как ручным, так и автоматизированным.

>Тестирование на проникновение (Penetration testing) - этот тип тестирования имитирует атаку злоумышленника. 
Это тестирование включает анализ конкретной системы для проверки потенциальных уязвимостей при попытке внешнего взлома. 

>Оценка рисков (Risk Assessment) тестирование включает анализ рисков безопасности, наблюдаемых в организации. 
Риски классифицируются как Низкие, Средние и Высокие. Это тестирование рекомендует меры по снижению риска. 

>Аудит безопасности (Security Auditing) - внутренняя проверка приложений и операционных систем на наличие уязвимостей. 
Аудит также может быть выполнен путем построчной проверки кода 

>Этический взлом (Ethical hacking) - совершается с целью выявления проблем безопасности в системе. Это делается White Hat 
хакерами - это специалисты по безопасности, которые использует свои навыки законным способом для помощи в выявлении 
дефектов системы, в отличии от Black Hat (преступников) или Gray Hat (что-то между).

>Оценка состояния (Posture Assessment) объединяет сканирование безопасности, этический взлом и оценки рисков, чтобы показать 
общее состояние безопасности организации.

53. Инсталяционное тестирование—
------------------------------------------------------------------------------------------------
(тестированием установки) подразумевают уровень корректности установки программного продукта с целью выявления степени 
ее готовности к эксплуатации. Тестирование инсталляции (установки) направленно на проверку успешной инсталляции и 
настройки, а также обновления или удаления программного обеспечения. Данный вид тестирования используется для проверки 
установки приложений и программ, как десктопных, так и мобильных.

Установка приложения	
>Установка должна начаться при клике по кнопке, подтверждающей данное действие
>Установки во всех поддерживаемых окружениях и на всех поддерживаемых платформах
>Установки в неподдерживаемых окружениях а также в нужных окружениях с некорректными настройками
>Права которые требует инсталляция (чаще всего они должны быть админскими), проверить установить приложение как гость
>Установки в clean state (при отсутствии любых возможных связанных файлов и предыдущих версий)
>Подсчитывается  ли при установке количество свободного места на диске и выдается ли предупреждение если места недостаточно
>Установки загруженного ранее приложения а так же прямая установка с использованием сети/беспроводного соединения
>Восстановится ли процесс установки при внезапном его прерывании (отключение устройства, отказ сети, отключение беспроводного соединения)
>Установка приложения, его запуск, удаление приложения должны возвращать систему в исходное состояние
>Распознается ли наличие в системе приложений/программ, необходимых для корректной работы устанавливаемого приложения
>Повторный запуск установки приложения при уже текущем должен выдавать корректное сообщение, двойная установка должна быть исключена
>Процесс установки может быть настраиваемый/дефолтный. Убедиться что оба корректно работают
>Наличие кнопки, которая предложит сохранить приложение в определенную папку а так же указывает дефолтное местоположение (“C:\programs\.”)
>Правильно ли установлены, сохранены ли в корректных папках файлы приложения
>Наличие созданных ярлыков, корректно ли они расположены
>После установки в системной вкладке “ Программы и компоненты” должны быть доступны: название приложения, иконка, 
имя издателя, размер приложения, дата установки и номер версии
>Настройки переменных сред PATH
>Убедиться что лицензионный ключ сохраняется в Windows Registry library
>Поддерживает ли приложение функции ‘UnInstall’, ‘Modify’, ‘ReInstall’ и корректно ли они работают
>Работа приложения с уже существующими DLL-файлами, с DLL-файлами приложений, которые необходимы для корректной работы устанавливаемого приложения
>Наличие инофрмации/сообщение о том, когда истекает срок действия установленной пробной версии приложения

Обновление приложения	

>Поддерживает ли приложение функцию обновления/автообновления
>При попытке установить ранее установленную версию приложения система должна ее распознать и выдать корректное сообщение
>Сохраняются ли пользовательские настройки при попытке загрузить новую версию/обновить старую версию
>При попытке обновить версию должны быть доступны функции удалить приложение и восстановить приложение
>Стандартные проверки как при первичной установке приложения
>Убедиться что номер версии приложения сменился новым
>Запустить приложение и убедиться что оно работает корректно

Откат до предыдущей версии	

>Попробовать установить старую версию на более новую
>Наличие корректного сообщения при попытке отката
>Убедиться что приложение работает корректно

Удаление приложения
	
>Не остается ли в системе никаких папок/файлов/ярлыков/ключей реестра после полного удаления приложения
>Корректно ли работает система после установки и последующего удаления приложения

52. Эксплуатационное приемочное тестирование
------------------------------------------------------------------------------------------------
Испытание на эксплуатацию (OAT) - это тип тестирования программного обеспечения, который оценивает 
операционную готовность программного приложения до его выпуска в производство. Целью эксплуатационного 
тестирования является обеспечение бесперебойной работы системы в ее стандартной операционной среде (SOE - standard 
operating environment). Это также называется Оперативное тестирование (Operational testing).

Примеры Test case:
>Резервные копии, сделанные на одном сайте, могут быть развернуты на тот же сайт 
>Резервные копии, сделанные на одном сайте, можно развернуть на другом сайте. 
>Внедрение любых новых функций в живую производственную среду не должно отрицательно влиять на целостность текущих производственных услуг. 
>Процесс внедрения может быть воспроизведен с использованием действующей документации 
>Каждый компонент может быть отключен и успешно запущен в согласованные сроки. 
>Для оповещений - все критические оповещения должны идти в TEC и ссылаться на документ правильного разрешения. 
>Оповещения созданы и выдаются при превышении согласованных пороговых значений 
>Любая документация по восстановлению, созданная или измененная, включая сервисные диаграммы, действительна 
>Это должно быть передано в соответствующие области поддержки. 
>Любой компонент, на который влияет сбой, должен показывать рекомендуемый порядок перезапуска, время завершения и т. д. 

51.Пользовательское приемочное тестирование (UAT) 
------------------------------------------------------------------------------------------------
- это тип тестирования, выполняемый конечным пользователем 
или клиентом для проверки / принятия ПО перед его перемещением в production. UAT выполняется на заключительном 
этапе тестирования после выполнения функциональных, интеграционных и системных испытаний. Основной целью 
UAT является проверка end-to-end business flow. Он не фокусируется на косметических ошибках, орфографических 
ошибках или тестировании системы. Приемочное тестирование пользователя выполняется в отдельной среде тестирования 
с настройкой данных, аналогичных производственным. Это своего рода тестирование черного ящика, в котором будут 
участвовать два или более конечных пользователя. 

Этапы:
>Анализ бизнес-требований 
>Создать плана тестирования UAT 
>Определить Test Scenario 
>Создать Test case UAT 
>Подготовить Test Data (Production like Data) 
>Запустить Test case
>Записать результаты
>Подтвердить бизнес-цели

50. Тестирование рабочего процесса
------------------------------------------------------------------------------------------------
Это тип тестирования программного обеспечения, который проверяет, что каждый software workflow точно отражает 
данный бизнес-процесс. Workflow - это серия задач для получения желаемого результата, которая обычно включает 
несколько этапов или шагов. Для любого бизнес-процесса тестирование этих последовательных шагов определяется 
как «WorkFlow testing». Например, убедитесь, что система может быть установлена ​​на платформе пользователя и 
работает правильно. Тестирование рабочего процесса проводится поэтапно. 

Вот как вы будете выполнять Workflow testing:
>Начальная фаза (Inception phase): эта фаза включает начальное планирование испытаний и тестирование прототипа 
>Фаза разработки (Elaboration phase): Эта фаза включает базовую архитектуру тестирования 
>Фаза строительства (Construction phase): эта фаза включает в себя значительные испытания в каждой сборке 
>Фаза перехода (Transition phase): Эта фаза включает в себя регрессионные тесты и повторные тесты исправлений

Тестирование workflow выполняется:
>Test engineer: планирует цели теста и график. Определяет Test case и процедуры. Оценивает результаты теста.
>Component engineer: Разработка тестовых компонентов. Автоматизирует некоторые тестовые процедуры.
>Integration Tester: Выполнение интеграционных тестов и выявление дефектов 
>System Testers: Выполнение системных тестов и отчеты о дефектах

49. Тестирование интерфейса
------------------------------------------------------------------------------------------------
Существует два типа интерфейсов для компьютерного приложения. 
Интерфейс командной строки, где вы вводите текст, и компьютер отвечает на эту команду и GUI - графический интерфейс 
пользователя, где вы взаимодействуете с компьютером, используя графическое представление, а не 
Цель тестирования графического интерфейса пользователя (GUI) - проверить функциональность интерфейса пользователя. 
Примеры:
>Тестирование размера, положения, ширины, высоты элементов. 
>Тестирование сообщений об ошибках, которые отображаются. 
>Тестирование разных разделов экрана. 
>Проверка шрифта, читаемый ли он или нет. 
>Тестирование экрана в разных разрешениях с помощью увеличения и уменьшения масштаба, например, 640 x 480, 600x800 и т. д. 
>Проверка выравнивания текстов и других элементов, таких как значки, кнопки и т. д. , находятся на своем месте или нет. 
>Тестирование цветов шрифтов. 
>Проверка цветов сообщений об ошибках, предупреждающих сообщений. 
>Проверка, имеет ли изображение хорошую четкость или нет. 
>Тестирование выравнивания изображений. 
>Проверка орфографии. 
>Пользователь не должен разочаровываться при использовании системного интерфейса. 
>Тестирование, является ли интерфейс привлекательным или нет. 
>Тестирование полос прокрутки в соответствии с размером страницы, если таковые имеются. 
>Тестирование отключенных полей, если таковые имеются. 
>Тестирование размера изображений. 
>Проверка заголовков, правильно ли они выровнены или нет. 
>Тестирование цвета гиперссылки.
>Визуальное тестирование проверяет корректность отображения пользователю web-сайта, мобильного или десктопного приложения, 
дизайн-системы, PDF-файла или отдельного изображения на наличие расхождений с спецификацией дизайна (рендеринг страниц, 
шрифтов, изображений и т. д.). Раньше выполнялось вручную, т.к., например, в случае веб-сайта классическое автоматизированное 
тестирование было бесполезно – большинство инструментов сверялись с DOM и не видели те ошибки, что человек мог увидеть вживую. 
Сейчас визуальное тестирование выполняется автоматизированными инструментами создания скриншотов и сверки их с эталоном. 

48. Отличия тестирование на удобство пользования и тестирования доступности
------------------------------------------------------------------------------------------------
USABILITY testing показывает, насколько проста в использовании и удобна система программного обеспечения. 
Здесь небольшой набор целевых конечных пользователей «использует» программную систему для выявления дефектов юзабилити. 
Основное внимание в этом тестировании уделяется простоте использования приложения пользователем, гибкости в управлении 
средствами управления и способности системы выполнять свои задачи. Это также называется тестированием пользовательского опыта 
(UX – "Ю-Экс", user experience). Это тестирование рекомендуется на начальном этапе разработки SDLC, что позволяет лучше понять 
ожидания пользователей.

Тестирование доступности (accessibility testing) - это подмножество юзабилити-тестирования. Его цель - убедиться в том, что наш продукт 
удобен в использовании для людей с различными видами инвалидности или особенностей восприятия. Это могут быть проблемы со зрением, 
слухом или ограничения в подвижности рук. 

47.Тестирование удобства использования (usability testing)
------------------------------------------------------------------------------------------------
Проверка программного продукта на соответствие с требованиями в плане удобности использования приложения. 
С помощью юзабилити-тестирования мы можем определить эргономичность (приспособленность к использовании) программы.

Проверка юзабилити приложения заключается в:
• Оценка соответствия дизайна приложения к его функциональности, заданной заказчиком.
• Анализ используемых графических элементов, цветового оформления с точки зрения восприятия.
• Оценке удобства навигации и ссылочной структуре.
• Анализ текстового наполнения сайта.
• Оценка удобства использования функциями приложения (сервисами, если это сайт).
• Анализ шрифтового оформления текста.

46. Нефункциональное тестирование 
------------------------------------------------------------------------------------------------
Тестирование свойств, которые не относятся к функциональности системы. 
Данные свойства определяются нефункциональными требованиями, которые характеризуют продукт с таких сторон, как:
>Надежность (реакция системы на непредвиденные ситуации).
>Производительность (Работоспособность системы под разными нагрузками).
>Удобство (Исследование удобности работы с приложением с точки зрения пользователя).
>Масштабируемость (Требования к горизонтальному или вертикальному масштабированию приложения).
>Безопасность (Защищенность пользовательских данных).
>Портируемость (Переносимость приложения на различные платформы).

45. Тестирование на соответствие
------------------------------------------------------------------------------------------------
-проводится для проверки соответствия продукта определенным стандартам, разработанным для эффективности.
Цель проверки соответствия состоит в том, чтобы определить, в какой степени отдельная реализация конкретного 
стандарта соответствует индивидуальным требованиям этого стандарта. 

Включает в себя: 
Производительность
Функции 
Прочность (Robustness)
Совместимость (Interoperability) 
Поведение системы

Тестирование соответствия может быть логическим или физическим, и оно включает в себя следующие типы тестирования: 
Тестирование на соответствие (Compliance testing)
Нагрузочное тестирование (Load testing)
Стресс тестирование (Stress testing)
Объемное тестирование (Volume testing)

44. Тестирование совместимости / взаимодействия
------------------------------------------------------------------------------------------------
Тестирование взаимодействия - функциональное тестирование, проверяющее способность приложения/устройства взаимодействовать с 
одним и более компонентами/системами/устройствами и включающее в себя тестирование совместимости (compatibility testing) и 
интеграционное тестирование (integration testing).

43. Функциональное тестирование
------------------------------------------------------------------------------------------------
Функциональное тестирование рассматривает заранее указанное поведение и основывается на анализе спецификаций функциональности 
компонента или системы в целом. Функциональные тесты основываются на функциях, выполняемых системой, и могут проводиться на всех 
уровнях тестирования (компонентном, интеграционном, системном, приемочном). Как правило, эти функции описываются в требованиях, 
функциональных спецификациях или в виде случаев использования системы (use cases).

42. Системное тестирование
------------------------------------------------------------------------------------------------
Системное тестирование рассматривает тестируемую систему в целом и оперирует на уровне пользовательских интерфейсов, 
в отличие от последних фаз интеграционного тестирования, которое оперирует на уровне интерфейсов модулей. 
Различны и цели этих уровней тестирования. На уровне системы часто сложно и малоэффективно анализировать прохождение 
тестовых траекторий внутри программы или отслеживать правильность работы конкретных функций. 
Основная задача системного тестирования - в выявлении дефектов, связанных с работой системы в целом, 
таких как неверное использование ресурсов системы, непредусмотренные комбинации данных пользовательского уровня, 
несовместимость с окружением, непредусмотренные сценарии использования, отсутствующая или неверная функциональность, 
неудобство в применении и тому подобное. 

Можно выделить два подхода к системному тестированию:

-на базе требований (requirements based)
(для каждого требования пишутся тестовые случаи (test cases), проверяющие выполнение данного требования.)
-на базе случаев использования (use case based)
(на основе представления о способах использования продукта создаются случаи использования системы (Use Cases). 
По конкретному случаю использования можно определить один или более сценариев. На проверку каждого сценария 
пишутся тест кейсы (test cases), которые должны быть протестированы.)

Можно автоматизировать:

Первый подход — это использовать вариацию MVC (model-view-controller) паттерна — Passive View.

*(MVC (model-view-controller) — подход к проектированию приложения, который предполагает выделение кода в блоки модель, 
представление и контроллер. Контроллер обрабатывает входящие запросы. Модель достаёт из базы данных информацию, нужную 
для выполнения конкретных запросов. Представление определяет результат запроса, который получает пользователь.)

Второй подход — использовать специальные инструменты для записи действий пользователя. То есть в итоге запускается 
сама программа, но щелканье по кнопкам осуществляется автоматически. Для .NET примером такого инструмента является 
White библиотека. Поддерживаются WinForms, WPF и еще несколько GUI платформ. Правило такое — на каждый use case 
пишется по скрипту, который описывает действия пользователя.

41. Тестовый драйвер / Тестовая заглушка
------------------------------------------------------------------------------------------------
Тестовый драйвер - это фрагмент кода, который вызывает тестируемый программный компонент. 
Это полезно при тестировании по принципу «снизу-вверх». 

Тестовая заглушка - это фиктивная программа, которая интегрируется с приложением для полной функциональности.

======================================= 
Пример: есть сценарий для проверки интерфейса между модулями A и B. Мы разработали только модуль-A. 
Затем мы можем проверить модуль-A, если у нас есть реальный модуль-B или фиктивный модуль для него. 
В этом случае мы называем модуль-B тестовой заглушкой.  2. Теперь модуль B не может отправлять или получать данные напрямую из модуля A. 
В таком сценарии мы перемещаем данные из одного модуля в другой, используя некоторые внешние функции, называемые Test Driver. 

Заглушки и драйверы не реализуют всю логику программного модуля, а только моделируют обмен данными с 
вызывающим модулем. Заглушка: вызывается тестируемым модулем. Драйвер: вызывает модуль для тестирования.

40. Отличие локализации от интернационализации
------------------------------------------------------------------------------------------------
Локализация— 
адаптация продукта и его документации к языковым соответствиям, культурным и другим требованиям целевого рынка или рынков (локалей).

- обязательно учитываются правовые требования, которые поддерживаются в различных регионах. К примеру, в России 
совершеннолетие наступает в 18 лет. В США в зависимости от штата этот возраст варьируется от 18 до 21 года, а в 
Японии молодые люди считаются совершеннолетними с 20 лет.
- поддержка валюты и операций с ней для каждой страны.
- специфические цвета и символы, которые могут иметь разный смысл в зависимости от региона, также должны 
учитываться при тестировании локализации.
- поддержка региональных раскладок клавиатур и работу горячих клавиш.
- интеграции со сторонними ресурсами (например, облачные хранилища), необходимо учитывать их доступность для 
регионов. К примеру, в Китае запрещено использование сервисов Google, DropBox, YouTube, Facebook.

Интернационализация  — 
представляет собой проектирование и создание продукта и документации, используя техники, упрощающие 
локализацию приложения.
 - UTF-кодировки
 - Форматы данных
 - Направление текста
 - Выделение локализованных элементов кода

39. Тетсирование N + 1.
 ------------------------------------------------------------------------------------------------
Вариант регрессионного тестирования представлен как N+1. В этом методе тестирование выполняется в несколько циклов, 
в которых ошибки, обнаруженные в тестовом цикле «N», устраняются и повторно тестируются в тестовом цикле N + 1. 
Цикл повторяется, пока не будет найдено ни одной ошибки.

38. Regression
------------------------------------------------------------------------------------------------
когда нужно убедится что новые (добавленные) функции приложения/ исправленные дефекты не оказали вляиния 
на текущую, уже существующую функциональность, работавшую и протестированную ранее.

37. Re-test 
------------------------------------------------------------------------------------------------
проводится в случае, если фича/ функциональность уже имела дифекты, и эти дефекты были недавно исправлены

36. Расширенное тестирование (extended)
------------------------------------------------------------------------------------------------
вид углубленного тестирования, при котором проверяется нестандартное использование програмного продукта.

35. Санитарное тестирование (sanity)
------------------------------------------------------------------------------------------------
используем каждый раз когда получаем относительно стабильный билд ПО. Проверяем работоспособность
в деталях. Валидация того, что важные части функциональности работают соглансо требованиям на низкому уровне.

34. Тест критического пути (critical path)
------------------------------------------------------------------------------------------------
проверка функциональности, используемой типичным пользователем в повседневной деятлеьности.

33. Дымовое (Smoke)
------------------------------------------------------------------------------------------------
короткий цикл тестов, определение общего состояния качества продукта, самой важной функциональности.
Считаем что представленная версия ПО относительно нестабильна.

32. Тестирование сборки
------------------------------------------------------------------------------------------------
Тестирование, направленное на определение соответствия, выпущенной версии, критериям качества для начала тестирования. 
По своим целям является аналогом Дымового Тестирования, направленного на приемку новой версии в дальнейшее 
тестирование или эксплуатацию. Вглубь оно может проникать дальше, в зависимости от требований к качеству выпущенной версии.

31. Monkey
------------------------------------------------------------------------------------------------
метод при котором прдоставляются случайные входные данные проверяя при этом поведение или наблюдая, произойдет ли сбой приложения
или системы.

30. Интуитивное тестирование ad-hoc testing / исследовательским.
------------------------------------------------------------------------------------------------
Ad-hoc testing — это более интуитивное и беспорядочное тестирование, когда тестировщик просто идет и проверяет, что ему хочется. 
У него нет определенной цели, структуры тестов в голове, какой-то системы. 

В свою очередь исследовательское тестирование более структурированное. 
Обычно тестировщик знает, что ему нужно проверить, у него в голове есть цель и какая-то система проведения тестов. 
Хоть тесты в этом случае не обязательно должны быть оформлены в виде тест кейсов.

29. Параллельное тестирование
------------------------------------------------------------------------------------------------
Это тип тестирования ПО, который одновременно проверяет несколько приложений или подкомпонентов одного приложения, чтобы сократить 
время выполнения теста. При параллельном тестировании тестировщик запускает две разные версии программного обеспечения одновременно с 
одним и тем же вводом. Цель состоит в том, чтобы выяснить, ведут ли себя прежняя система и новая система одинаково или по-разному. 

28. End-to-end тестирование 
------------------------------------------------------------------------------------------------
это процесс тестирования приложения на всех уровнях – начиная с фронтенда и заканчивая бэкэндом, 
включая интерфейс и конечные точки. 
https://codernet.ru/articles/drugoe/end-to-end_ili_e2e-proczess_chto_eto_skvoznoe_testirovanie/

27. Сквозное тестирование
------------------------------------------------------------------------------------------------
Сквозное тестирование - это стратегия тестирования для выполнения тестов, которые охватывают все возможные потоки приложения от его 
начала до конца; проверяет программную систему вместе с ее интеграцией с внешними интерфейсами. Целью сквозного тестирования является 
создание полного производственного сценария, выявление программных зависимостей и утверждение, что между различными программными 
модулями и подсистемами передается правильный ввод. Сквозное тестирование обычно выполняется после функционального и системного тестирования. 

26. A/B-тестирование 
------------------------------------------------------------------------------------------------
— это маркетинговый метод, использующийся для оценки и управления эффективностью веб-страницы. 
Этот метод также называется сплит-тестированием (от англ. split testing — раздельное тестирование).

Допустим, специалист предполагает, что изменив цвет конверсионной кнопки с нейтрального голубого на агрессивный красный, он сделает ее более заметной. 
Чтобы проверить, приведет ли это к увеличению продаж и росту конверсии, маркетолог создает усовершенствованный вариант веб-страницы 
(B, новая страница).
С помощью инструментов для проведения сплит-тестирования эксперт в случайном порядке разделяет трафик между страницами A и B на две 
приблизительно равные части. Условно говоря, половина посетителей попадает на страницу A, а вторая половина на страницу B. 
При этом маркетолог держит в уме источники трафика. Чтобы обеспечить валидность и объективность тестирования, необходимо направить на страницы 
A и B по 50% посетителей, пришедших на сайт из социальных сетей, естественного поиска, контекстной рекламы и т.п.
Собрав достаточно информации, маркетолог оценивает результаты тестирования. Как сказано выше, коэффициент конверсии страницы A составляет 2%. 
Если на странице B этот показатель составил 2,5%, значит изменение конверсионной кнопки с голубого на красный цвет действительно увеличило 
эффективность лэндинга. Однако показатель конверсии не достиг желаемых 4%. Поэтому маркетолог дальше ищет способы совершенствования страницы с у
помощью A/B-тестирования. При этом в качестве контрольной выступит уже страница с красной конверсионной кнопкой.

25. SIT - System Integration testing
------------------------------------------------------------------------------------------------
Это тип тестирования программного обеспечения, проводимого в интегрированной аппаратной и 
программной среде для проверки поведения всей системы. Это тестирование, проведенное на полной 
интегрированной системе для оценки соответствия системы ее установленным требованиям.

Также проверяет сосуществование программной системы с другими и тестирует интерфейс между модулями 
программного приложения. В этом типе тестирования модули сначала тестируются индивидуально, а затем объединяются в систему. 
Например, программные и / или аппаратные компоненты объединяются и тестируются постепенно, пока не будет интегрирована вся система.

24. Разница между Unit / Integration
------------------------------------------------------------------------------------------------
Если тест использует:
 + базу данных,
 + сеть для вызова другого компонента/приложения,
 + внешнюю систему (например, очередь или почтовый сервер),
 + читает/записывает файлы или выполняет другие операции ввода-вывода,
 + полагается не на исходный код, а на бинарник приложения,
… то это интеграционный, а не модульный тест

Юнит-тесты легче поддерживать.
Юнит-тесты легко воспроизводят пограничные случаи и редкие ситуации.
Юнит-тесты выполняются гораздо быстрее интеграционных тестов.
Сбойные юнит-тесты легче исправить, чем интеграционные.

23. Интеграционное тестирование
------------------------------------------------------------------------------------------------
 -предназначено для проверки насколько хорошо два или более модулей ПО взаимодействуют друг с другом, 
 а также взаимодействия с различными частями системы (операционной системой, оборудованием либо связи между различными системами).

Интеграционное тестирование отличается от других видов тестирования тем, что он сосредоточен в основном на интерфейсах и потоке данных 
(между модулями). Здесь приоритет проверки присваивается интегрирующим ссылкам, а не функциям блока, которые уже проверены.

Пример тестирования интеграции для следующего сценария:
Приложение имеет 3 модуля, например «Страница входа», «Почтовый ящик» и «Удалить электронную почту». 
Каждый из них интегрирован логически.

Здесь нет нужды тестировать страницу входа, т.к. это уже было сделано в модульном тестировании. 
Но проверьте, как это интегрировано со страницей почтового ящика.
Аналогично, «Почтовый ящик»: проверьте его интеграцию с модулем «Удалить электронную почту».

Стратегии:
1) Подход Большого взрыва.
(Здесь все компоненты собираются вместе, а затем тестируются)
2) Инкрементальный подход:
(в данном подходе тестирование выполняется путем объединения двух или более логически связанных модулей, 
затем добавляются другие связанные модули и проверяются на правильность функционирования, 
процесс продолжается до тех пор, пока все модули не будут соединены и успешно протестированы.)

Поэтапный подход, в свою очередь, осуществляется двумя разными методами:
>Снизу вверх
>Сверху вниз
 
Заглушка и драйвер
Инкрементальный подход осуществляется с помощью фиктивных программ, называемых заглушками и драйверами. 
Заглушки и драйверы не реализуют всю логику программного модуля, а только моделируют обмен данными с вызывающим модулем.

-Нисходящий подход (сверху вниз)
(при подходе «сверху вниз» тестирование, что логично, выполняется сверху вниз, следуя потоку управления программной 
системы. Используются заглушки для тестирования.)

-Подход «снизу вверх»
(в восходящей стратегии каждый модуль на более низких уровнях тестируется с модулями более высоких уровней, пока не 
будут протестированы все модули. Требуется помощь драйверов для тестирования)

-Сэндвич – комбинация «сверху вниз» и «снизу вверх»
Эта стратегия представляет собой комбинацию подходов «сверху вниз» и «снизу вверх». Здесь верхнеуровневые модули 
тестируются с нижнеуровневыми, а нижнеуровневые модули интегрируются с верхнеуровневыми, соответственно, и тестируются. 
Эта стратегия использует и заглушки, и драйверы.

22. Компонентное / модульное / юнит тестирование
------------------------------------------------------------------------------------------------
Модульное тестирование (юнит-тестирование). Модульные тесты используются для тестирования какого-либо одного логически выделенного и 
изолированного элемента системы. Это тестирование методом белого ящика и чаще всего оно проводится самими разработчиками. 

Компонентное тестирование. Тип тестирования ПО, при котором тестирование выполняется для каждого отдельного компонента отдельно, 
без интеграции с другими компонентами. Его также называют модульным тестированием (Module testing), если рассматривать его с точки зрения архитектуры. 
Как правило, любое программное обеспечение в целом состоит из нескольких компонентов. 
Тестирование на уровне компонентов (Component Level testing) имеет дело с тестированием этих компонентов индивидуально. 
Это один из самых частых типов тестирования черного ящика, который проводится командой QA.

====================================================================================================================
                                    Unit testing	                                                                                                                              Component testing
 + Тестирование отдельных программ, модулей, функций                                                       + Тестирование каждого объекта или частей программного обеспечения отдельно 
   для демонстрации того, что программа выполняется согласно спецификации	                 с или без изоляции других объектов
 + Проверка в(на) соответствии с design documents	                                                                   + Проверка в(на) соответствии с test requirements, use case
 + Пишутся и выполняются(обычно) разработчиками	                                                 + Тестировщиками
 + Выполняется первым	                                                                                                      + Выполняется после Unit

====================================================================================================================

21. Неразрушающее / Позитивное / Недеструктивное 
------------------------------------------------------------------------------------------------
Это тип тестирования программного обеспечения, который включает в себя правильное взаимодействие с программным обеспечением. 
Неразрушающее тестирование (NDT) также можно назвать позитивным тестированием или тестированием «счастливого пути». 
Это дает ожидаемые результаты и доказывает, что программное обеспечение ведет себя так, как ожидалось. 
Пример: - Ввод правильных данных в модуль входа в систему и проверка, принимает ли он учетные данные и переходит на следующую страницу

20. Негативное / Деструктивное / Разрушающее
------------------------------------------------------------------------------------------------
Негативное тестирование — тестирование при котором мы ожидаем, что приложение будет корректно обрабатывать проблемные 
сценарии как с валидным вводом пользователя (например, попытка добавить существующее имя пользователя), так и с недопустимым 
вводом пользователя (попытка добавить имя пользователя, которое имеет значение null).

Деструктивное тестирование — это метод тестирования, при котором приложение выполняется неконтролируемым образом, чтобы 
проверить работоспособность приложения, а также найти точку отказа.

Разрушающее — проводится в самых тяжелых условиях эксплуатации и продолжается до тех пор, пока приложение не сломается. 

19. Пирамида 
------------------------------------------------------------------------------------------------
Пирамида тестов — абстракция, которая означает группировку тестов программного обеспечения по разным уровням детализации.
Она также даёт представление, сколько тестов должно быть в каждой из этих групп. 
          ∆
        /Ui\
      / API \
    /  UNIT \
Из этой пирамиды главное запомнить два принципа:
   Писать тесты разной детализации.
   Чем выше уровень, тем меньше тестов.

Тестовая пирамида - визуализация, описывающая различные уровни тестирования и объем тестирования на каждом слое тестирования.

18. Методы тестирования:
------------------------------------------------------------------------------------------------
    +метод "Чёрного ящика" (Black box testing)
Тестировщик имеет доступ к ПО только через те же интерфейсы, что и заказчик или пользователь, либо через внешние интерфейсы, 
позволяющие другому компьютеру либо другому процессу подключиться к системе для тестирования.

    +метод "Белого ящика" (White box or «glass-box» testing)
Разработчик теста имеет доступ к исходному коду и может писать код, который связан с библиотеками тестируемого ПО. 
Это типично для юнит-тестирования , при котором тестируются только отдельные части системы. 
Оно обеспечивает то, что компоненты конструкции - работоспособны и устойчивы, до определенной степени.

    +метод "Серого ящика" (Grey box)
Метод тестирования программного продукта или приложения с частичным знанием его внутреннего устройства. 
Для выполнения тестирования «серого ящика» нет необходимости в доступе тестировщика к исходному коду.

17. Виды тестирования:
------------------------------------------------------------------------------------------------
    +Функциональные
Функциональные тесты базируются на функциях и особенностях, а также взаимодействии с другими системами, 
и могут быть представлены на всех уровнях тестирования: компонентном или модульном (Component/Unit testing), 
интеграционном (Integration testing), системном (System testing) и приемочном (Acceptance testing). 
Функциональные виды тестирования рассматривают внешнее поведение системы. 
Далее перечислены одни из самых распространенных видов функциональных тестов:

Функциональное тестирование (Functional testing)
Тестирование безопасности (Security and Access Control Testing)
Тестирование взаимодействия (Interoperability Testing)

    +Нефункциональные
Описывает тесты, необходимые для определения характеристик программного обеспечения, которые могут быть измерены различными величинами. 
В целом, это тестирование того, "Как" система работает. 

Все виды тестирования производительности:
нагрузочное тестирование (Performance and Load Testing)
стрессовое тестирование (Stress Testing)
тестирование стабильности или надежности (Stability / Reliability Testing)
объемное тестирование (Volume Testing)
Тестирование установки (Installation testing)
Тестирование удобства пользования (Usability Testing)
Тестирование на отказ и восстановление (Failover and Recovery Testing)
Конфигурационное тестирование (Configuration Testing)

     +Связанные с изменениями
После проведения необходимых изменений, таких как исправление бага/дефекта, программное обеспечение должно 
быть пере тестировано для подтверждения того факта, что проблема была действительно решена. 
Ниже перечислены виды тестирования, которые необходимо проводить после установки программного обеспечения, 
для подтверждения работоспособности приложения или правильности осуществленного исправления дефекта:

Дымовое тестирование (Smoke Testing)
Регрессионное тестирование (Regression Testing)
Тестирование сборки (Build Verification Test)
Санитарное тестирование или проверка согласованности/исправности (Sanity Testing)

16. Бизнес логика 
------------------------------------------------------------------------------------------------
- это то, что программа должна сделать. Это правлиа которые заключены в самом бизнесе. 
(это реализация правил и ограничений автоматизируемых операций.)

15. Пилотное тестирование 
------------------------------------------------------------------------------------------------
— это своего рода репетиция, позволяющая проверить исследовательский подход на небольшом количестве участников. 
Для чего: 
в ходе исследования участники не понимают, что от них требуется и что они должны сделать;
формулировки ваших вопросов наталкивают участников на определенный ответ либо являются причиной искажения результатов;
в течение эксперимента участники не успевают выполнить задачу за отведенное время;
после проведения эксперимента больше времени отнимает анализ структуры эксперимента, а не его результатов.

14. Бета тестирование
------------------------------------------------------------------------------------------------
Использование почти готовой версии продукта  с целью выявления максимального числа ошибок в его работе для их последующего устранения 
перед окончательным выходом продукта на рынок, к массовому потребителю.
В отличие от альфа-тестирования, проводимого силами штатных разработчиков или тестировщиков, 
бета-тестирование предполагает привлечение добровольцев из числа обычных будущих пользователей продукта, 
которым доступна предварительная версия продукта (так называемая бета-версия).

13. Тестовые данные 
------------------------------------------------------------------------------------------------
Тестовые данные на самом деле являются входными данными для программы. 
Он представляет данные, которые влияют или зависят от выполнения определенного модуля. 
Хорошо разработанные данные тестирования позволяют выявлять и исправлять серьезные недостатки в функциональности. 
Выбор выбранных тестовых данных должен быть переоценен на каждом этапе многофазного цикла разработки продукта.

12. Как мы узнаем, было ли создано достаточно тестов для тестирования продуктов?
------------------------------------------------------------------------------------------------
Изначально проверим, охватывает ли каждое требование хотя бы один Test case. 
Если да, то можно сказать, что тестовых примеров достаточно для тестирования продукта. 

11. Тестирование продукта требования к которому еще не зафиксированы.
------------------------------------------------------------------------------------------------
Спек недоступен для продукта, тогда план тестирования может быть создан на основе предположений, 
сделанных относительно продукта. Но мы должны хорошо документировать все предположения в плане тестирования. 

10. Этапы тестирования
------------------------------------------------------------------------------------------------
Работа с требованиями. Знакомство с требованиями заказчика, что должен из себя представлять итоговый продукт, обсуждение.
Разработка стратегии тестирования. Оценка сроков тестирования, выявление среды тестирования, объединение всей информации, 
полученной при работе с требованиями.
Создание тестовой документации. Написание сценариев, которые позволят проверить функционал.
Тестирование прототипа. Тестирование основного функционала продукта, корректировка целей, добавление фичей.
Основное тестирование. Выполнение общей проверки продукта.
Стабилизация. На данном этапе происходит работа над устранением багов.
Эксплуатация. Проводится регресс-тестирование, устранение ошибок, которые нашел конечный пользователь.

9. Тестирование делится на отдельные этапы потому что:
------------------------------------------------------------------------------------------------
    Каждый этап испытаний имеет свое назначение 
    Проще управлять поэтапно 
    Мы можем запустить разные тесты в разных средах 
    Производительность и качество тестирования улучшаются с помощью поэтапного тестирования

8. Тестирование со сдвигом влево 
------------------------------------------------------------------------------------------------
- это подход к тестированию программного обеспечения и системного тестирования, 
при котором тестирование выполняется на более ранней стадии жизненного цикла (т. Е. Перемещается влево на временной шкале проекта). 
Сдвиг-влево тестирование - https://ru.abcdef.wiki/wiki/Shift-left_testing

7. Независимое тестирование (аутсорсинг тестирования) 
------------------------------------------------------------------------------------------------
- это тестирование силами дополнительно привлечённой компании или группы людей, 
не участвующих непосредственно в разработке программного обеспечения

6. Принципы тестирования
------------------------------------------------------------------------------------------------
  +Тестирование показывает наличие дефектов
  +Тестирование может показать наличие дефектов в программе, но не доказать их отсутствие. 
  +Исчерпывающее тестирование невозможно
  +Раннее тестирование
  +Скопление дефектов
  +Парадокс пестицида
  +Тестирование зависит от контекста
  +Заблуждение об отсутствии ошибок.

5. Критерии выбора тестов
------------------------------------------------------------------------------------------------
Требования к идеальному критерию формулируются следующим образом:
>Достаточность, т. е. критерий должен показывать, когда некоторое конечное множество тестов достаточно для тестирования данной программы;
>Полнота, т. е. в случае ошибки должен существовать тест из множества тестов, удовлетворяющих критерию, который раскрывает ошибку;
>Надежность, т. е. любые два множества тестов, удовлетворяющих ему, одновременно должны раскрывать или не раскрывать ошибки программы;
>Проверяемость, т. е. критерий должен быть легко проверяемым, например, вычисляемым на тестах.

4. Импакт анализ- 
------------------------------------------------------------------------------------------------
это указание затронутых мест в проекте при разработке новой или изменении старой функциональности. 
Во время разработки часто возникают ситуации, когда вносишь изменения в одном месте, а это влияет либо на весь проект либо на несколько мест в проекте

3. Фазы тестирования
------------------------------------------------------------------------------------------------
Основными фазами тестирования являются:
– модульное тестирование;
– интеграционное тестирование;
– системное тестирование (в том числе адаптационное, функциональное и нагрузочное);
– регрессионное тестирование;
– приемочное тестирование.

2. Билд от релиз отличается тем, что
------------------------------------------------------------------------------------------------
Билд- это версия программного обеспечения, которую команда разработчиков передает команде тестирования для целей тестирования, а Release - 
это программное обеспечение, которое команда тестирования передает клиенту.

1.Среда тестирования 
------------------------------------------------------------------------------------------------
— это настройка программного и аппаратного обеспечения для групп тестирования для выполнения тестовых случаев.
Виды тестовых сред:
Тестирование на тестовом сервере
Тестирование локальных сборок
Тестирование примеров приложений на специфичных языках программирования
Тестирование аппаратных продуктов
