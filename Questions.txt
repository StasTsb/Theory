62. Уровни требований
-------------------------------------------------------------------------------------------------------------------------
-Пользовательские требования
 (описывают задачи, которые пользователь может выполнять с помощью 
разрабатываемого продукта, а также способы (сценарии) их решения в системе 
 (реакция продукта на действия пользователя, сценарии работы пользователя).

-Бизнес требования 
 (то как мы заработаем на продукте)

-Продуктные требования
*Функциональные требования (Functional Requirements) — охватывают 
предполагаемое поведение системы, определяя действия, которые система 
способна выполнять. Описывается в системной спецификации. 
В основном влияют на дизайн системы.
*Нефункциональные требования (Non-functional Requirements) 
—  охватывают свойства системы (удобства использования, надежность, 
масштабируемость), которыми она должна обладать при реализации своего поведения.

62. TCPandUDP
-------------------------------------------------------------------------------------------------------------------------

61. CI&CD
-------------------------------------------------------------------------------------------------------------------------
Continuous Integration, (CI) Непрерывная интеграция — 
это методология разработки и набор практик, при которых в код вносятся небольшие 
изменения с частыми коммитами. 

Цель CI — обеспечить последовательный и автоматизированный способ сборки, упаковки 
и тестирования приложений. При налаженном процессе непрерывной интеграции разработчики 
с большей вероятностью будут делать частые коммиты, что, в свою очередь, будет способствовать 
улучшению коммуникации и повышению качества программного обеспечения.

Команды, внедряющие непрерывную интеграцию, часто начинают с настройки системы контроля версий 
и определения порядка работы. Несмотря на то что коммиты делаются часто, реализация фич и исправление 
багов могут выполняться довольно долго. Для контроля того, какие фичи и код готовы существует несколько подходов.

Многие используют фича-флаги (feature flag) — механизм для включения и выключения функционала в 
рантайме. Функционал, который еще находится в стадии разработки, оборачивается фича-флагами и развертывается 
из master-ветки в продакшн, но отключается до тех пор, пока не будет полностью готов к использованию. 

Другой способ работы с фичами — использование веток в системе контроля версий. В этом случае надо определить 
модель ветвления (например, такую как Gitflow) и описать как код попадает в ветки разработки, тестирования и продакшена. 
Для фич с длительным циклом разработки создаются отдельные фича-ветки. После завершения работы над фичей разработчики 
сливают изменения из фича-ветки в основную ветку разработки. Такой подход работает хорошо, но может быть неудобен, 
если одновременно разрабатывается много фич.

Большинство CI/CD-инструментов позволяет запускать сборку вручную, по коммиту или по расписанию. Командам необходимо 
обсудить расписание сборки, которое подходит для них в зависимости от численности команды, ожидаемого количества 
ежедневных коммитов и других критериев. Важно, чтобы коммиты и сборка были быстрыми, иначе долгая сборка может 
стать препятствием для разработчиков, пытающихся быстро и часто коммитить.

Continuous Delivery, (CD) Непрерывная поставка —
это автоматическое развертывание приложения в целевое окружение.
CD автоматически разворачивает приложения и выполняет дополнительные тесты.

60. Baseline and Benchmark
------------------------------------------------------------------------------------------------
Baseline - это подход к тестированию, в котором за точку отсчета берется базовая линия - это показатель 
конкретного ориентира, который служит основой для нового тестирования. В базовом тестировании тесты 
собирают и сохраняют все результаты, полученные в исходном коде, и сравнивают с эталонным базовым уровнем. 
Этот базовый уровень относится к последним принятым результатам испытаний. Если в исходном коде есть новые 
изменения, то для повторного выполнения тестов необходимо сформировать текущий базовый уровень. 
Если последние результаты будут приняты, то текущая базовая линия станет эталонной. По большей части Baseline 
testing относят к тестированию производительности.

Benchmark - включает в себя проведение серии программных тестов на аппаратном обеспечении, которые копируют 
виды задач, которые он будет выполнять в реальных условиях.

Baseline предназначено для оценки производительности приложения. 
Benchmark сравнивает производительность приложения с отраслевым стандартом. 

Baseline тестирование использует данные, собранные для повышения производительности. 
Benchmark возвращает информацию о целевом приложении по сравнению с другими приложениями.

Baseline тестирование сравнивает текущую производительность с предыдущей производительностью приложения, 
Benchmark сравнивает производительность нашего приложения с производительностью конкурентов.

59. Матрица трассировки
------------------------------------------------------------------------------------------------
— Метод визуализации связей между элементами системы в форме таблицы. Матрица трассировки создается путем 
связывания бизнес-требований с вариантами использования и сценариями тестирования, которые будут использоваться для их проверки.
Трассировка обеспечивает полноту тестирования и подготавливает основу для планирования тестов. 

Правила нумерации:
бизнес-требования: BR001, BR002
функциональные требования (вкл. нумерации для соответствующего бизнес-требования): FR001.01, FR001.02
технические спецификации: TS001.01.01, TS001.01.02, 

ID Матрицы  |  Бизнес-требования  |  Функциональные требования  |  Вариант использования  |   Сценарий тестирования   |     Комментарии

58. Мутационное тестирование 
------------------------------------------------------------------------------------------------
— это метод тестирования ПО, основанный на всевозможных изменениях исходного 
кода и проверке реакции на эти изменения набора автоматических тестов. Если тесты после изменения кода успешно 
выполняются, значит либо код не покрыт тестами, либо написанные тесты неэффективны. Критерий, определяющий 
эффективность набора автоматических тестов, называется Mutation Score Indicator (MSI).

57. Ramp тестирование
------------------------------------------------------------------------------------------------
Это метод тестирования, который предлагает ступенчато поднимать нагрузку до тех пор, пока система не выйдет из строя. 

56. Тестирование потоков
 ------------------------------------------------------------------------------------------------
Определяется как тип тестирования программного обеспечения, который проверяет основные функциональные возможности 
конкретной задачи (потока). Обычно проводится на ранней стадии фазы интеграционного тестирования. 

Тестирование на основе потоков подразделяется на две категории:
Однопоточное тестирование включает одну транзакцию приложения за раз 
Многопоточное тестирование включает одновременно несколько активных транзакций

Как производить:
>Тестирование на основе потоков является обобщенной формой тестирования на основе сеансов (session-based testing), 
в котором сеансы являются формой потока, но поток не обязательно является сеансом. 
>Для тестирования потока, поток или программа (небольшая функциональность) интегрируются и тестируются постепенно 
как подсистема, а затем выполняются для всей системы. 
>На самом низком уровне оно предоставляет интеграторам лучшее представление о том, что тестировать. 
Вместо непосредственного тестирования программных компонентов требуется, чтобы интеграторы сосредоточились на 
тестировании логических путей выполнения в контексте всей системы.

55.Конфигурационное тестирование
------------------------------------------------------------------------------------------------
Конфигурационное тестирование (Configuration testing) — специальный вид тестирования, направленный на проверку работы 
ПО при различных аппаратных и программных конфигурациях системы (заявленных платформах, поддерживаемых драйверах, при 
различных конфигурациях компьютеров и т. д. ) 

В зависимости от типа проекта конфигурационное тестирование может иметь разные цели:
>Проект по профилированию работы системы 
Цель Тестирования: определить оптимальную конфигурацию оборудования, обеспечивающую требуемые характеристики 
производительности и времени реакции тестируемой системы.

>Проект по миграции системы с одной платформы на другую 
Цель Тестирования: Проверить объект тестирования на совместимость с объявленным в спецификации оборудованием, 
операционными системами и программными продуктами третьих фирм.
Для клиент-серверных приложений конфигурационное тестирование можно условно разделить на два уровня 
(для некоторых типов приложений может быть актуален только один):

>Серверный
>Клиентский

54. Тестирование безопасности
------------------------------------------------------------------------------------------------
Это тип тестирования ПО, который выявляет уязвимости, угрозы и риски. 
Целью тестов безопасности является выявление всех возможных лазеек и слабых мест в ПО, 
которые могут привести к потере информации, доходов, репутации компании, 
сотрудников или клиентов. Общая стратегия безопасности основывается на трех основных принципах:

>Конфиденциальность - сокрытие определенных ресурсов или информации
>Целостность – ресурс может быть изменен только в соответствии с полномочиями пользователя
>Доступность - ресурсы должны быть доступны только авторизованному пользователю, внутреннему объекту или устройству

Тестирование безопасности обычно выполняет отдельный специалист по безопасности. 
В ходе тестирования безопасности испытатель производит следующие манипуляции: 

>попытки узнать пароль с помощью внешних средств;
>атака системы с помощью специальных утилит, анализирующих защиты;
>подавление, ошеломление системы (в надежде, что она откажется обслуживать других клиентов);
>целенаправленное введение ошибок в надежде проникнуть в систему в ходе восстановления;
>просмотр несекретных данных в надежде найти ключ для входа в систему.

Типы тестирования безопасности:
>Сканирование уязвимостей/оценка защищенности (Vulnerability Scanning) выполняется с помощью автоматизированного 
ПО для сканирования системы на наличие известных сигнатур уязвимостей. 

>Сканирование безопасности (Security Scanning) включает в себя выявление слабых сторон сети и системы, а затем 
предоставляет решения для снижения этих рисков. Это сканирование может быть выполнено как ручным, так и автоматизированным.

>Тестирование на проникновение (Penetration testing) - этот тип тестирования имитирует атаку злоумышленника. 
Это тестирование включает анализ конкретной системы для проверки потенциальных уязвимостей при попытке внешнего взлома. 

>Оценка рисков (Risk Assessment) тестирование включает анализ рисков безопасности, наблюдаемых в организации. 
Риски классифицируются как Низкие, Средние и Высокие. Это тестирование рекомендует меры по снижению риска. 

>Аудит безопасности (Security Auditing) - внутренняя проверка приложений и операционных систем на наличие уязвимостей. 
Аудит также может быть выполнен путем построчной проверки кода 

>Этический взлом (Ethical hacking) - совершается с целью выявления проблем безопасности в системе. Это делается White Hat 
хакерами - это специалисты по безопасности, которые использует свои навыки законным способом для помощи в выявлении 
дефектов системы, в отличии от Black Hat (преступников) или Gray Hat (что-то между).

>Оценка состояния (Posture Assessment) объединяет сканирование безопасности, этический взлом и оценки рисков, чтобы показать 
общее состояние безопасности организации.

53. Инсталяционное тестирование—
------------------------------------------------------------------------------------------------
(тестированием установки) подразумевают уровень корректности установки программного продукта с целью выявления степени 
ее готовности к эксплуатации. Тестирование инсталляции (установки) направленно на проверку успешной инсталляции и 
настройки, а также обновления или удаления программного обеспечения. Данный вид тестирования используется для проверки 
установки приложений и программ, как десктопных, так и мобильных.

Установка приложения	
>Установка должна начаться при клике по кнопке, подтверждающей данное действие
>Установки во всех поддерживаемых окружениях и на всех поддерживаемых платформах
>Установки в неподдерживаемых окружениях а также в нужных окружениях с некорректными настройками
>Права которые требует инсталляция (чаще всего они должны быть админскими), проверить установить приложение как гость
>Установки в clean state (при отсутствии любых возможных связанных файлов и предыдущих версий)
>Подсчитывается  ли при установке количество свободного места на диске и выдается ли предупреждение если места недостаточно
>Установки загруженного ранее приложения а так же прямая установка с использованием сети/беспроводного соединения
>Восстановится ли процесс установки при внезапном его прерывании (отключение устройства, отказ сети, отключение беспроводного соединения)
>Установка приложения, его запуск, удаление приложения должны возвращать систему в исходное состояние
>Распознается ли наличие в системе приложений/программ, необходимых для корректной работы устанавливаемого приложения
>Повторный запуск установки приложения при уже текущем должен выдавать корректное сообщение, двойная установка должна быть исключена
>Процесс установки может быть настраиваемый/дефолтный. Убедиться что оба корректно работают
>Наличие кнопки, которая предложит сохранить приложение в определенную папку а так же указывает дефолтное местоположение (“C:\programs\.”)
>Правильно ли установлены, сохранены ли в корректных папках файлы приложения
>Наличие созданных ярлыков, корректно ли они расположены
>После установки в системной вкладке “ Программы и компоненты” должны быть доступны: название приложения, иконка, 
имя издателя, размер приложения, дата установки и номер версии
>Настройки переменных сред PATH
>Убедиться что лицензионный ключ сохраняется в Windows Registry library
>Поддерживает ли приложение функции ‘UnInstall’, ‘Modify’, ‘ReInstall’ и корректно ли они работают
>Работа приложения с уже существующими DLL-файлами, с DLL-файлами приложений, которые необходимы для корректной работы устанавливаемого приложения
>Наличие инофрмации/сообщение о том, когда истекает срок действия установленной пробной версии приложения

Обновление приложения	

>Поддерживает ли приложение функцию обновления/автообновления
>При попытке установить ранее установленную версию приложения система должна ее распознать и выдать корректное сообщение
>Сохраняются ли пользовательские настройки при попытке загрузить новую версию/обновить старую версию
>При попытке обновить версию должны быть доступны функции удалить приложение и восстановить приложение
>Стандартные проверки как при первичной установке приложения
>Убедиться что номер версии приложения сменился новым
>Запустить приложение и убедиться что оно работает корректно

Откат до предыдущей версии	

>Попробовать установить старую версию на более новую
>Наличие корректного сообщения при попытке отката
>Убедиться что приложение работает корректно

Удаление приложения
	
>Не остается ли в системе никаких папок/файлов/ярлыков/ключей реестра после полного удаления приложения
>Корректно ли работает система после установки и последующего удаления приложения

52. Эксплуатационное приемочное тестирование
------------------------------------------------------------------------------------------------
Испытание на эксплуатацию (OAT) - это тип тестирования программного обеспечения, который оценивает 
операционную готовность программного приложения до его выпуска в производство. Целью эксплуатационного 
тестирования является обеспечение бесперебойной работы системы в ее стандартной операционной среде (SOE - standard 
operating environment). Это также называется Оперативное тестирование (Operational testing).

Примеры Test case:
>Резервные копии, сделанные на одном сайте, могут быть развернуты на тот же сайт 
>Резервные копии, сделанные на одном сайте, можно развернуть на другом сайте. 
>Внедрение любых новых функций в живую производственную среду не должно отрицательно влиять на целостность текущих производственных услуг. 
>Процесс внедрения может быть воспроизведен с использованием действующей документации 
>Каждый компонент может быть отключен и успешно запущен в согласованные сроки. 
>Для оповещений - все критические оповещения должны идти в TEC и ссылаться на документ правильного разрешения. 
>Оповещения созданы и выдаются при превышении согласованных пороговых значений 
>Любая документация по восстановлению, созданная или измененная, включая сервисные диаграммы, действительна 
>Это должно быть передано в соответствующие области поддержки. 
>Любой компонент, на который влияет сбой, должен показывать рекомендуемый порядок перезапуска, время завершения и т. д. 

51.Пользовательское приемочное тестирование (UAT) 
------------------------------------------------------------------------------------------------
- это тип тестирования, выполняемый конечным пользователем 
или клиентом для проверки / принятия ПО перед его перемещением в production. UAT выполняется на заключительном 
этапе тестирования после выполнения функциональных, интеграционных и системных испытаний. Основной целью 
UAT является проверка end-to-end business flow. Он не фокусируется на косметических ошибках, орфографических 
ошибках или тестировании системы. Приемочное тестирование пользователя выполняется в отдельной среде тестирования 
с настройкой данных, аналогичных производственным. Это своего рода тестирование черного ящика, в котором будут 
участвовать два или более конечных пользователя. 

Этапы:
>Анализ бизнес-требований 
>Создать плана тестирования UAT 
>Определить Test Scenario 
>Создать Test case UAT 
>Подготовить Test Data (Production like Data) 
>Запустить Test case
>Записать результаты
>Подтвердить бизнес-цели

50. Тестирование рабочего процесса
------------------------------------------------------------------------------------------------
Это тип тестирования программного обеспечения, который проверяет, что каждый software workflow точно отражает 
данный бизнес-процесс. Workflow - это серия задач для получения желаемого результата, которая обычно включает 
несколько этапов или шагов. Для любого бизнес-процесса тестирование этих последовательных шагов определяется 
как «WorkFlow testing». Например, убедитесь, что система может быть установлена ​​на платформе пользователя и 
работает правильно. Тестирование рабочего процесса проводится поэтапно. 

Вот как вы будете выполнять Workflow testing:
>Начальная фаза (Inception phase): эта фаза включает начальное планирование испытаний и тестирование прототипа 
>Фаза разработки (Elaboration phase): Эта фаза включает базовую архитектуру тестирования 
>Фаза строительства (Construction phase): эта фаза включает в себя значительные испытания в каждой сборке 
>Фаза перехода (Transition phase): Эта фаза включает в себя регрессионные тесты и повторные тесты исправлений

Тестирование workflow выполняется:
>Test engineer: планирует цели теста и график. Определяет Test case и процедуры. Оценивает результаты теста.
>Component engineer: Разработка тестовых компонентов. Автоматизирует некоторые тестовые процедуры.
>Integration Tester: Выполнение интеграционных тестов и выявление дефектов 
>System Testers: Выполнение системных тестов и отчеты о дефектах

49. Тестирование интерфейса
------------------------------------------------------------------------------------------------
Существует два типа интерфейсов для компьютерного приложения. 
Интерфейс командной строки, где вы вводите текст, и компьютер отвечает на эту команду и GUI - графический интерфейс 
пользователя, где вы взаимодействуете с компьютером, используя графическое представление, а не 
Цель тестирования графического интерфейса пользователя (GUI) - проверить функциональность интерфейса пользователя. 
Примеры:
>Тестирование размера, положения, ширины, высоты элементов. 
>Тестирование сообщений об ошибках, которые отображаются. 
>Тестирование разных разделов экрана. 
>Проверка шрифта, читаемый ли он или нет. 
>Тестирование экрана в разных разрешениях с помощью увеличения и уменьшения масштаба, например, 640 x 480, 600x800 и т. д. 
>Проверка выравнивания текстов и других элементов, таких как значки, кнопки и т. д. , находятся на своем месте или нет. 
>Тестирование цветов шрифтов. 
>Проверка цветов сообщений об ошибках, предупреждающих сообщений. 
>Проверка, имеет ли изображение хорошую четкость или нет. 
>Тестирование выравнивания изображений. 
>Проверка орфографии. 
>Пользователь не должен разочаровываться при использовании системного интерфейса. 
>Тестирование, является ли интерфейс привлекательным или нет. 
>Тестирование полос прокрутки в соответствии с размером страницы, если таковые имеются. 
>Тестирование отключенных полей, если таковые имеются. 
>Тестирование размера изображений. 
>Проверка заголовков, правильно ли они выровнены или нет. 
>Тестирование цвета гиперссылки.
>Визуальное тестирование проверяет корректность отображения пользователю web-сайта, мобильного или десктопного приложения, 
дизайн-системы, PDF-файла или отдельного изображения на наличие расхождений с спецификацией дизайна (рендеринг страниц, 
шрифтов, изображений и т. д.). Раньше выполнялось вручную, т.к., например, в случае веб-сайта классическое автоматизированное 
тестирование было бесполезно – большинство инструментов сверялись с DOM и не видели те ошибки, что человек мог увидеть вживую. 
Сейчас визуальное тестирование выполняется автоматизированными инструментами создания скриншотов и сверки их с эталоном. 

48. Отличия тестирование на удобство пользования и тестирования доступности
------------------------------------------------------------------------------------------------
USABILITY testing показывает, насколько проста в использовании и удобна система программного обеспечения. 
Здесь небольшой набор целевых конечных пользователей «использует» программную систему для выявления дефектов юзабилити. 
Основное внимание в этом тестировании уделяется простоте использования приложения пользователем, гибкости в управлении 
средствами управления и способности системы выполнять свои задачи. Это также называется тестированием пользовательского опыта 
(UX – "Ю-Экс", user experience). Это тестирование рекомендуется на начальном этапе разработки SDLC, что позволяет лучше понять 
ожидания пользователей.

Тестирование доступности (accessibility testing) - это подмножество юзабилити-тестирования. Его цель - убедиться в том, что наш продукт 
удобен в использовании для людей с различными видами инвалидности или особенностей восприятия. Это могут быть проблемы со зрением, 
слухом или ограничения в подвижности рук. 

47.Тестирование удобства использования (usability testing)
------------------------------------------------------------------------------------------------
Проверка программного продукта на соответствие с требованиями в плане удобности использования приложения. 
С помощью юзабилити-тестирования мы можем определить эргономичность (приспособленность к использовании) программы.

Проверка юзабилити приложения заключается в:
• Оценка соответствия дизайна приложения к его функциональности, заданной заказчиком.
• Анализ используемых графических элементов, цветового оформления с точки зрения восприятия.
• Оценке удобства навигации и ссылочной структуре.
• Анализ текстового наполнения сайта.
• Оценка удобства использования функциями приложения (сервисами, если это сайт).
• Анализ шрифтового оформления текста.

46. Нефункциональное тестирование 
------------------------------------------------------------------------------------------------
Тестирование свойств, которые не относятся к функциональности системы. 
Данные свойства определяются нефункциональными требованиями, которые характеризуют продукт с таких сторон, как:
>Надежность (реакция системы на непредвиденные ситуации).
>Производительность (Работоспособность системы под разными нагрузками).
>Удобство (Исследование удобности работы с приложением с точки зрения пользователя).
>Масштабируемость (Требования к горизонтальному или вертикальному масштабированию приложения).
>Безопасность (Защищенность пользовательских данных).
>Портируемость (Переносимость приложения на различные платформы).

45. Тестирование на соответствие
------------------------------------------------------------------------------------------------
-проводится для проверки соответствия продукта определенным стандартам, разработанным для эффективности.
Цель проверки соответствия состоит в том, чтобы определить, в какой степени отдельная реализация конкретного 
стандарта соответствует индивидуальным требованиям этого стандарта. 

Включает в себя: 
Производительность
Функции 
Прочность (Robustness)
Совместимость (Interoperability) 
Поведение системы

Тестирование соответствия может быть логическим или физическим, и оно включает в себя следующие типы тестирования: 
Тестирование на соответствие (Compliance testing)
Нагрузочное тестирование (Load testing)
Стресс тестирование (Stress testing)
Объемное тестирование (Volume testing)

44. Тестирование совместимости / взаимодействия
------------------------------------------------------------------------------------------------
Тестирование взаимодействия - функциональное тестирование, проверяющее способность приложения/устройства взаимодействовать с 
одним и более компонентами/системами/устройствами и включающее в себя тестирование совместимости (compatibility testing) и 
интеграционное тестирование (integration testing).

43. Функциональное тестирование
------------------------------------------------------------------------------------------------
Функциональное тестирование рассматривает заранее указанное поведение и основывается на анализе спецификаций функциональности 
компонента или системы в целом. Функциональные тесты основываются на функциях, выполняемых системой, и могут проводиться на всех 
уровнях тестирования (компонентном, интеграционном, системном, приемочном). Как правило, эти функции описываются в требованиях, 
функциональных спецификациях или в виде случаев использования системы (use cases).

42. Системное тестирование
------------------------------------------------------------------------------------------------
Системное тестирование рассматривает тестируемую систему в целом и оперирует на уровне пользовательских интерфейсов, 
в отличие от последних фаз интеграционного тестирования, которое оперирует на уровне интерфейсов модулей. 
Различны и цели этих уровней тестирования. На уровне системы часто сложно и малоэффективно анализировать прохождение 
тестовых траекторий внутри программы или отслеживать правильность работы конкретных функций. 
Основная задача системного тестирования - в выявлении дефектов, связанных с работой системы в целом, 
таких как неверное использование ресурсов системы, непредусмотренные комбинации данных пользовательского уровня, 
несовместимость с окружением, непредусмотренные сценарии использования, отсутствующая или неверная функциональность, 
неудобство в применении и тому подобное. 

41. Тестовый драйвер / Тестовая заглушка
------------------------------------------------------------------------------------------------
Тестовый драйвер - это фрагмент кода, который вызывает тестируемый программный компонент. 
Это полезно при тестировании по принципу «снизу-вверх». 

Тестовая заглушка - это фиктивная программа, которая интегрируется с приложением для полной функциональности.

======================================= 
Пример: есть сценарий для проверки интерфейса между модулями A и B. Мы разработали только модуль-A. 
Затем мы можем проверить модуль-A, если у нас есть реальный модуль-B или фиктивный модуль для него. 
В этом случае мы называем модуль-B тестовой заглушкой.  2. Теперь модуль B не может отправлять или получать данные напрямую из модуля A. 
В таком сценарии мы перемещаем данные из одного модуля в другой, используя некоторые внешние функции, называемые Test Driver. 

Заглушки и драйверы не реализуют всю логику программного модуля, а только моделируют обмен данными с 
вызывающим модулем. Заглушка: вызывается тестируемым модулем. Драйвер: вызывает модуль для тестирования.

40. Отличие локализации от интернационализации
------------------------------------------------------------------------------------------------
Локализация— 
адаптация продукта и его документации к языковым соответствиям, культурным и другим требованиям целевого рынка или рынков (локалей).

- обязательно учитываются правовые требования, которые поддерживаются в различных регионах. К примеру, в России 
совершеннолетие наступает в 18 лет. В США в зависимости от штата этот возраст варьируется от 18 до 21 года, а в 
Японии молодые люди считаются совершеннолетними с 20 лет.
- поддержка валюты и операций с ней для каждой страны.
- специфические цвета и символы, которые могут иметь разный смысл в зависимости от региона, также должны 
учитываться при тестировании локализации.
- поддержка региональных раскладок клавиатур и работу горячих клавиш.
- интеграции со сторонними ресурсами (например, облачные хранилища), необходимо учитывать их доступность для 
регионов. К примеру, в Китае запрещено использование сервисов Google, DropBox, YouTube, Facebook.

Интернационализация  — 
представляет собой проектирование и создание продукта и документации, используя техники, упрощающие 
локализацию приложения.
 - UTF-кодировки
 - Форматы данных
 - Направление текста
 - Выделение локализованных элементов кода

39. Тетсирование N + 1.
 ------------------------------------------------------------------------------------------------
Вариант регрессионного тестирования представлен как N+1. В этом методе тестирование выполняется в несколько циклов, 
в которых ошибки, обнаруженные в тестовом цикле «N», устраняются и повторно тестируются в тестовом цикле N + 1. 
Цикл повторяется, пока не будет найдено ни одной ошибки.

38. Regression
------------------------------------------------------------------------------------------------
когда нужно убедится что новые (добавленные) функции приложения/ исправленные дефекты не оказали вляиния 
на текущую, уже существующую функциональность, работавшую и протестированную ранее.

37. Re-test 
------------------------------------------------------------------------------------------------
проводится в случае, если фича/ функциональность уже имела дифекты, и эти дефекты были недавно исправлены

36. Расширенное тестирование (extended)
------------------------------------------------------------------------------------------------
вид углубленного тестирования, при котором проверяется нестандартное использование програмного продукта.

35. Санитарное тестирование (sanity)
------------------------------------------------------------------------------------------------
используем каждый раз когда получаем относительно стабильный билд ПО. Проверяем работоспособность
в деталях. Валидация того, что важные части функциональности работают соглансо требованиям на низкому уровне.

34. Тест критического пути (critical path)
------------------------------------------------------------------------------------------------
проверка функциональности, используемой типичным пользователем в повседневной деятлеьности.

33. Дымовое (Smoke)
------------------------------------------------------------------------------------------------
короткий цикл тестов, определение общего состояния качества продукта, самой важной функциональности.
Считаем что представленная версия ПО относительно нестабильна.

32. Тестирование сборки
------------------------------------------------------------------------------------------------
Тестирование, направленное на определение соответствия, выпущенной версии, критериям качества для начала тестирования. 
По своим целям является аналогом Дымового Тестирования, направленного на приемку новой версии в дальнейшее 
тестирование или эксплуатацию. Вглубь оно может проникать дальше, в зависимости от требований к качеству выпущенной версии.

31. Monkey
------------------------------------------------------------------------------------------------
метод при котором прдоставляются случайные входные данные проверяя при этом поведение или наблюдая, произойдет ли сбой приложения
или системы.

30. Интуитивное тестирование ad-hoc testing / исследовательским.
------------------------------------------------------------------------------------------------
Ad-hoc testing — это более интуитивное и беспорядочное тестирование, когда тестировщик просто идет и проверяет, что ему хочется. 
У него нет определенной цели, структуры тестов в голове, какой-то системы. 

В свою очередь исследовательское тестирование более структурированное. 
Обычно тестировщик знает, что ему нужно проверить, у него в голове есть цель и какая-то система проведения тестов. 
Хоть тесты в этом случае не обязательно должны быть оформлены в виде тест кейсов.

29. Параллельное тестирование
------------------------------------------------------------------------------------------------
Это тип тестирования ПО, который одновременно проверяет несколько приложений или подкомпонентов одного приложения, чтобы сократить 
время выполнения теста. При параллельном тестировании тестировщик запускает две разные версии программного обеспечения одновременно с 
одним и тем же вводом. Цель состоит в том, чтобы выяснить, ведут ли себя прежняя система и новая система одинаково или по-разному. 

28. End-to-end тестирование 
------------------------------------------------------------------------------------------------
это процесс тестирования приложения на всех уровнях – начиная с фронтенда и заканчивая бэкэндом, 
включая интерфейс и конечные точки. 
https://codernet.ru/articles/drugoe/end-to-end_ili_e2e-proczess_chto_eto_skvoznoe_testirovanie/

27. Сквозное тестирование
------------------------------------------------------------------------------------------------
Сквозное тестирование - это стратегия тестирования для выполнения тестов, которые охватывают все возможные потоки приложения от его 
начала до конца; проверяет программную систему вместе с ее интеграцией с внешними интерфейсами. Целью сквозного тестирования является 
создание полного производственного сценария, выявление программных зависимостей и утверждение, что между различными программными 
модулями и подсистемами передается правильный ввод. Сквозное тестирование обычно выполняется после функционального и системного тестирования. 

26. A/B-тестирование 
------------------------------------------------------------------------------------------------
— это маркетинговый метод, использующийся для оценки и управления эффективностью веб-страницы. 
Этот метод также называется сплит-тестированием (от англ. split testing — раздельное тестирование).

Допустим, специалист предполагает, что изменив цвет конверсионной кнопки с нейтрального голубого на агрессивный красный, он сделает ее более заметной. 
Чтобы проверить, приведет ли это к увеличению продаж и росту конверсии, маркетолог создает усовершенствованный вариант веб-страницы 
(B, новая страница).
С помощью инструментов для проведения сплит-тестирования эксперт в случайном порядке разделяет трафик между страницами A и B на две 
приблизительно равные части. Условно говоря, половина посетителей попадает на страницу A, а вторая половина на страницу B. 
При этом маркетолог держит в уме источники трафика. Чтобы обеспечить валидность и объективность тестирования, необходимо направить на страницы 
A и B по 50% посетителей, пришедших на сайт из социальных сетей, естественного поиска, контекстной рекламы и т.п.
Собрав достаточно информации, маркетолог оценивает результаты тестирования. Как сказано выше, коэффициент конверсии страницы A составляет 2%. 
Если на странице B этот показатель составил 2,5%, значит изменение конверсионной кнопки с голубого на красный цвет действительно увеличило 
эффективность лэндинга. Однако показатель конверсии не достиг желаемых 4%. Поэтому маркетолог дальше ищет способы совершенствования страницы с у
помощью A/B-тестирования. При этом в качестве контрольной выступит уже страница с красной конверсионной кнопкой.

25. SIT - System Integration testing
------------------------------------------------------------------------------------------------
Это тип тестирования программного обеспечения, проводимого в интегрированной аппаратной и 
программной среде для проверки поведения всей системы. Это тестирование, проведенное на полной 
интегрированной системе для оценки соответствия системы ее установленным требованиям.

Также проверяет сосуществование программной системы с другими и тестирует интерфейс между модулями 
программного приложения. В этом типе тестирования модули сначала тестируются индивидуально, а затем объединяются в систему. 
Например, программные и / или аппаратные компоненты объединяются и тестируются постепенно, пока не будет интегрирована вся система.

24. Разница между Unit / Integration
------------------------------------------------------------------------------------------------
Если тест использует:
 + базу данных,
 + сеть для вызова другого компонента/приложения,
 + внешнюю систему (например, очередь или почтовый сервер),
 + читает/записывает файлы или выполняет другие операции ввода-вывода,
 + полагается не на исходный код, а на бинарник приложения,
… то это интеграционный, а не модульный тест

Юнит-тесты легче поддерживать.
Юнит-тесты легко воспроизводят пограничные случаи и редкие ситуации.
Юнит-тесты выполняются гораздо быстрее интеграционных тестов.
Сбойные юнит-тесты легче исправить, чем интеграционные.

23. Интеграционное тестирование
------------------------------------------------------------------------------------------------
 -предназначено для проверки насколько хорошо два или более модулей ПО взаимодействуют друг с другом, 
 а также взаимодействия с различными частями системы (операционной системой, оборудованием либо связи между различными системами).

22. Компонентное / модульное / юнит тестирование
------------------------------------------------------------------------------------------------
Модульное тестирование (юнит-тестирование). Модульные тесты используются для тестирования какого-либо одного логически выделенного и 
изолированного элемента системы. Это тестирование методом белого ящика и чаще всего оно проводится самими разработчиками. 

Компонентное тестирование. Тип тестирования ПО, при котором тестирование выполняется для каждого отдельного компонента отдельно, 
без интеграции с другими компонентами. Его также называют модульным тестированием (Module testing), если рассматривать его с точки зрения архитектуры. 
Как правило, любое программное обеспечение в целом состоит из нескольких компонентов. 
Тестирование на уровне компонентов (Component Level testing) имеет дело с тестированием этих компонентов индивидуально. 
Это один из самых частых типов тестирования черного ящика, который проводится командой QA.

====================================================================================================================
                                    Unit testing	                                                                                                                              Component testing
 + Тестирование отдельных программ, модулей, функций                                                       + Тестирование каждого объекта или частей программного обеспечения отдельно 
   для демонстрации того, что программа выполняется согласно спецификации	                 с или без изоляции других объектов
 + Проверка в(на) соответствии с design documents	                                                                   + Проверка в(на) соответствии с test requirements, use case
 + Пишутся и выполняются(обычно) разработчиками	                                                 + Тестировщиками
 + Выполняется первым	                                                                                                      + Выполняется после Unit

====================================================================================================================

21. Неразрушающее / Позитивное / Недеструктивное 
------------------------------------------------------------------------------------------------
Это тип тестирования программного обеспечения, который включает в себя правильное взаимодействие с программным обеспечением. 
Неразрушающее тестирование (NDT) также можно назвать позитивным тестированием или тестированием «счастливого пути». 
Это дает ожидаемые результаты и доказывает, что программное обеспечение ведет себя так, как ожидалось. 
Пример: - Ввод правильных данных в модуль входа в систему и проверка, принимает ли он учетные данные и переходит на следующую страницу

20. Негативное / Деструктивное / Разрушающее
------------------------------------------------------------------------------------------------
Негативное тестирование — тестирование при котором мы ожидаем, что приложение будет корректно обрабатывать проблемные 
сценарии как с валидным вводом пользователя (например, попытка добавить существующее имя пользователя), так и с недопустимым 
вводом пользователя (попытка добавить имя пользователя, которое имеет значение null).

Деструктивное тестирование — это метод тестирования, при котором приложение выполняется неконтролируемым образом, чтобы 
проверить работоспособность приложения, а также найти точку отказа.

Разрушающее — проводится в самых тяжелых условиях эксплуатации и продолжается до тех пор, пока приложение не сломается. 

19. Пирамида 
------------------------------------------------------------------------------------------------
Пирамида тестов — абстракция, которая означает группировку тестов программного обеспечения по разным уровням детализации.
Она также даёт представление, сколько тестов должно быть в каждой из этих групп. 
          ∆
        /Ui\
      / API \
    /  UNIT \
Из этой пирамиды главное запомнить два принципа:
   Писать тесты разной детализации.
   Чем выше уровень, тем меньше тестов.

Тестовая пирамида - визуализация, описывающая различные уровни тестирования и объем тестирования на каждом слое тестирования.

18. Методы тестирования:
------------------------------------------------------------------------------------------------
    +метод "Чёрного ящика" (Black box testing)
Тестировщик имеет доступ к ПО только через те же интерфейсы, что и заказчик или пользователь, либо через внешние интерфейсы, 
позволяющие другому компьютеру либо другому процессу подключиться к системе для тестирования.

    +метод "Белого ящика" (White box or «glass-box» testing)
Разработчик теста имеет доступ к исходному коду и может писать код, который связан с библиотеками тестируемого ПО. 
Это типично для юнит-тестирования , при котором тестируются только отдельные части системы. 
Оно обеспечивает то, что компоненты конструкции - работоспособны и устойчивы, до определенной степени.

    +метод "Серого ящика" (Grey box)
Метод тестирования программного продукта или приложения с частичным знанием его внутреннего устройства. 
Для выполнения тестирования «серого ящика» нет необходимости в доступе тестировщика к исходному коду.

17. Виды тестирования:
------------------------------------------------------------------------------------------------
    +Функциональные
Функциональные тесты базируются на функциях и особенностях, а также взаимодействии с другими системами, 
и могут быть представлены на всех уровнях тестирования: компонентном или модульном (Component/Unit testing), 
интеграционном (Integration testing), системном (System testing) и приемочном (Acceptance testing). 
Функциональные виды тестирования рассматривают внешнее поведение системы. 
Далее перечислены одни из самых распространенных видов функциональных тестов:

Функциональное тестирование (Functional testing)
Тестирование безопасности (Security and Access Control Testing)
Тестирование взаимодействия (Interoperability Testing)

    +Нефункциональные
Описывает тесты, необходимые для определения характеристик программного обеспечения, которые могут быть измерены различными величинами. 
В целом, это тестирование того, "Как" система работает. 

Все виды тестирования производительности:
нагрузочное тестирование (Performance and Load Testing)
стрессовое тестирование (Stress Testing)
тестирование стабильности или надежности (Stability / Reliability Testing)
объемное тестирование (Volume Testing)
Тестирование установки (Installation testing)
Тестирование удобства пользования (Usability Testing)
Тестирование на отказ и восстановление (Failover and Recovery Testing)
Конфигурационное тестирование (Configuration Testing)

     +Связанные с изменениями
После проведения необходимых изменений, таких как исправление бага/дефекта, программное обеспечение должно 
быть пере тестировано для подтверждения того факта, что проблема была действительно решена. 
Ниже перечислены виды тестирования, которые необходимо проводить после установки программного обеспечения, 
для подтверждения работоспособности приложения или правильности осуществленного исправления дефекта:

Дымовое тестирование (Smoke Testing)
Регрессионное тестирование (Regression Testing)
Тестирование сборки (Build Verification Test)
Санитарное тестирование или проверка согласованности/исправности (Sanity Testing)

16. Бизнес логика 
------------------------------------------------------------------------------------------------
- это то, что программа должна сделать. Это правлиа которые заключены в самом бизнесе. 
(это реализация правил и ограничений автоматизируемых операций.)

15. Пилотное тестирование 
------------------------------------------------------------------------------------------------
— это своего рода репетиция, позволяющая проверить исследовательский подход на небольшом количестве участников. 
Для чего: 
в ходе исследования участники не понимают, что от них требуется и что они должны сделать;
формулировки ваших вопросов наталкивают участников на определенный ответ либо являются причиной искажения результатов;
в течение эксперимента участники не успевают выполнить задачу за отведенное время;
после проведения эксперимента больше времени отнимает анализ структуры эксперимента, а не его результатов.

14. Бета тестирование
------------------------------------------------------------------------------------------------
Использование почти готовой версии продукта  с целью выявления максимального числа ошибок в его работе для их последующего устранения 
перед окончательным выходом продукта на рынок, к массовому потребителю.
В отличие от альфа-тестирования, проводимого силами штатных разработчиков или тестировщиков, 
бета-тестирование предполагает привлечение добровольцев из числа обычных будущих пользователей продукта, 
которым доступна предварительная версия продукта (так называемая бета-версия).

13. Тестовые данные 
------------------------------------------------------------------------------------------------
Тестовые данные на самом деле являются входными данными для программы. 
Он представляет данные, которые влияют или зависят от выполнения определенного модуля. 
Хорошо разработанные данные тестирования позволяют выявлять и исправлять серьезные недостатки в функциональности. 
Выбор выбранных тестовых данных должен быть переоценен на каждом этапе многофазного цикла разработки продукта.

12. Как мы узнаем, было ли создано достаточно тестов для тестирования продуктов?
------------------------------------------------------------------------------------------------
Изначально проверим, охватывает ли каждое требование хотя бы один Test case. 
Если да, то можно сказать, что тестовых примеров достаточно для тестирования продукта. 

11. Тестирование продукта требования к которому еще не зафиксированы.
------------------------------------------------------------------------------------------------
Спек недоступен для продукта, тогда план тестирования может быть создан на основе предположений, 
сделанных относительно продукта. Но мы должны хорошо документировать все предположения в плане тестирования. 

10. Этапы тестирования
------------------------------------------------------------------------------------------------
Работа с требованиями. Знакомство с требованиями заказчика, что должен из себя представлять итоговый продукт, обсуждение.
Разработка стратегии тестирования. Оценка сроков тестирования, выявление среды тестирования, объединение всей информации, 
полученной при работе с требованиями.
Создание тестовой документации. Написание сценариев, которые позволят проверить функционал.
Тестирование прототипа. Тестирование основного функционала продукта, корректировка целей, добавление фичей.
Основное тестирование. Выполнение общей проверки продукта.
Стабилизация. На данном этапе происходит работа над устранением багов.
Эксплуатация. Проводится регресс-тестирование, устранение ошибок, которые нашел конечный пользователь.

9. Тестирование делится на отдельные этапы потому что:
------------------------------------------------------------------------------------------------
    Каждый этап испытаний имеет свое назначение 
    Проще управлять поэтапно 
    Мы можем запустить разные тесты в разных средах 
    Производительность и качество тестирования улучшаются с помощью поэтапного тестирования

8. Тестирование со сдвигом влево 
------------------------------------------------------------------------------------------------
- это подход к тестированию программного обеспечения и системного тестирования, 
при котором тестирование выполняется на более ранней стадии жизненного цикла (т. Е. Перемещается влево на временной шкале проекта). 
Сдвиг-влево тестирование - https://ru.abcdef.wiki/wiki/Shift-left_testing

7. Независимое тестирование (аутсорсинг тестирования) 
------------------------------------------------------------------------------------------------
- это тестирование силами дополнительно привлечённой компании или группы людей, 
не участвующих непосредственно в разработке программного обеспечения

6. Принципы тестирования
------------------------------------------------------------------------------------------------
  +Тестирование показывает наличие дефектов
  +Тестирование может показать наличие дефектов в программе, но не доказать их отсутствие. 
  +Исчерпывающее тестирование невозможно
  +Раннее тестирование
  +Скопление дефектов
  +Парадокс пестицида
  +Тестирование зависит от контекста
  +Заблуждение об отсутствии ошибок.

5. Критерии выбора тестов
------------------------------------------------------------------------------------------------
Требования к идеальному критерию формулируются следующим образом:
>Достаточность, т. е. критерий должен показывать, когда некоторое конечное множество тестов достаточно для тестирования данной программы;
>Полнота, т. е. в случае ошибки должен существовать тест из множества тестов, удовлетворяющих критерию, который раскрывает ошибку;
>Надежность, т. е. любые два множества тестов, удовлетворяющих ему, одновременно должны раскрывать или не раскрывать ошибки программы;
>Проверяемость, т. е. критерий должен быть легко проверяемым, например, вычисляемым на тестах.

4. Импакт анализ- 
------------------------------------------------------------------------------------------------
это указание затронутых мест в проекте при разработке новой или изменении старой функциональности. 
Во время разработки часто возникают ситуации, когда вносишь изменения в одном месте, а это влияет либо на весь проект либо на несколько мест в проекте

3. Фазы тестирования
------------------------------------------------------------------------------------------------
Основными фазами тестирования являются:
– модульное тестирование;
– интеграционное тестирование;
– системное тестирование (в том числе адаптационное, функциональное и нагрузочное);
– регрессионное тестирование;
– приемочное тестирование.

2. Билд от релиз отличается тем, что
------------------------------------------------------------------------------------------------
Билд- это версия программного обеспечения, которую команда разработчиков передает команде тестирования для целей тестирования, а Release - 
это программное обеспечение, которое команда тестирования передает клиенту.

1.Среда тестирования 
------------------------------------------------------------------------------------------------
— это настройка программного и аппаратного обеспечения для групп тестирования для выполнения тестовых случаев.
Виды тестовых сред:
Тестирование на тестовом сервере
Тестирование локальных сборок
Тестирование примеров приложений на специфичных языках программирования
Тестирование аппаратных продуктов