****************************Техники тест-дизайна*********************************

– это совокупность правил, позволяющих правильно определить 
список проверок для тестирования. 
===============================================================
По уровням:
> Первый уровень – проверка элементов системы (например, полей, чекбоксов, кнопок и т.д.)

> Второй уровень – проверка логики работы системы при комбинации данных в элементах системы
Техники тест-дизайна 2-го уровня отвечают за вариативность (наличие нескольких или многих вариантов 
чего-либо) и комбинаторику ( все возможные перестановки элементов, цифр, каких-л. данных и т. п.) 
данных при проверке ПО

> Третий уровень – проверка бизнес- процесса системы и логики работы программы.

_______________________________________________________________                                      

+ КЛАСС ЭКВИВАЛЕНТНОСТИ (Equivalence class) – это набор входных (или выходных) данных ПО, которые 
обрабатываются программой по одному алгоритму или приводят к одному результату.
Это множество значений, которые можно подставлять в программу и получать один и тот же результат.

Делятся на два класса:
-Позитивные
-Негативные

Пример:
(Процентная ставка)
От 18 до 25 лет – 18%
От 25 до 45 лет – 16 %
Свыше 45 лет – 20%

Позитивные (3):
1) 18-24
2) 25-44
3) 45 +

Негативные сценарии:
(Формируются исходя из необходимости проверки отказов программы) 
1) 0
2) 1-17
3) отрицательные значения, ввод символов и т.д.

Результатом такого разбиения будет значение (диапазон значений), 
в котором необходимо выполнить всего одну проверку с любым значением из диапазона данных.

Результат:
Позитивные проверки: Ввод значений: 19, 30, 48 (значения могут быть любыми из диапазона)
Негативные проверки: 0, 3, -1, * и т.д.

_______________________________________________________________   

+ ГРАНИЧНЫЕ ЗНАЧЕНИЯ – техника тест-дизайна, которая дополняет классы эквивалентности 
дополнительными проверками на границе изменения условий.

Пример:
(Процентная ставка)
От 18 до 25 лет – 18%
От 25 до 45 лет – 16 %
Свыше 45 лет – 20%

Границы наших классов: 17, 18, 19, 24, 25, 26, 44, 45, 46 и max.
учтем негативный класс это от 0 до 18.
Граничные значения: -1, 0, 1, 17,18

исключаем повторки и получаем:

-1, 0, 1, 17, 18, 19, 24, 25, 26, 44, 45, 46, max.

Граничные значения определяются не только для числовых значений, но и для буквенных (например, 
границы алфавита и кодировки), даты и времени, смысловых значений. Граница числовых значений 
зависит от формата ввода, если у вас целые числа, например, 2, то граничные значения будут 1 и 3. 
Если дробные значения, то границы для числа 2 уже будут 1,9 (1,99) или 2,1 (2,01) и т.д.

_______________________________________________________________   

+ ПОПАРНОЕ ТЕСТИРОВАНИЕ (Parwise Testing)
- каждое значение каждого проверяемого параметра должно быть протестировано на взаимодействие с 
каждым значением всех остальных параметров. После составления такой матрицы мы убираем тесты, 
которые дублируют друг друга, оставляя максимальное покрытие при минимальном необходимом наборе 
сценариев.  

Для Parwise достаточно, чтобы каждое значение всех параметров хотя бы единожды сочеталось с 
другими значениями остальных параметров. Таким образом, матрицу можно значительно сократить. 

Например:

№	Браузер	              ОC 	                 Язык
--------------------------------------------------------------------------
1	Opera	              Windows	               	RU
2	Google Chrome	       Linux	     	          RU
3	Opera	               Linux		              EN
4	Google Chrome	      Windows		              EN

При составлении матрицы принятия решений для двух браузеров, двух ОС и двух языков было бы нужно 
8 сценариев. При попарном тестировании достаточно четырех. 

Программа попарного независимого комбинированного тестирования 
– Pairwise Independent Combinatorial Testing (PICT)
(Shift + right)
(.\pict.exe initial.txt > cases_pict.xls)

_______________________________________________________________   

+ ТАБЛИЦА ПРИНЯТИЯ РЕШЕНИЙ (Decision Table Testing).
– инструмент для фиксирования требований и описания функциональности приложения. 
Таблицами очень удобно описывать бизнес-логику.

В тестировании таблица решений используется для того, чтобы на основе требований составить тест-кейсы. 
И ничего не забыть при сложных комбинациях входных условий. Каждая строка или столбец 
таблицы → готовый тест-кейс.

Как составлять таблицу:

По горизонтали — выписываем условия, которые влияют на результат. 
А чуть ниже — сам результат, в оригинале Action — действие, которое нужно выполнить.
По вертикали — правила: конкретная комбинация входных условий.

Пример со страховкой:

Условия         Правило 1    Правило 2    Правило 3   Правило 4
-------------------------------------------------------------------------------------------------

Стаж 5 лет        Нет              Нет                  Да                  Да

Был в 
авариях?           Да                Нет                 Да                  Нет

Результат

Страховка     200 руб        100 руб            50 руб            10 руб


Наглядность — таблица нагляднее текста. Можно взять таблицу и подойти к аналитику с каким-то 
вопросом. Или к разработчику. Им будет проще понять, о чём речь, чем если вы принесете стену текста.

Нарисовал таблицу = записал тест-кейсы. Поменял в заголовках слово «правило» на «тест-кейс», 
и вот они, готовые тесты! И это будут основные позитивные тесты, которые мы проводим в первую очередь.

Наглядность поможет найти баги в документации. Так как косяк формулы будет сразу бросаться в глаза.

Таблица помогает взглянуть на ТЗ свежим взглядом, по-новому. Пока мы пытаемся перекомбинировать 
условия, составляя таблицу, мы можем заметить пропущенный ранее баг.

_______________________________________________________________   

+ПРЕДУГАДЫВАНИЕ ОШИБКИ (Error Guessing - EG). 

Когда тест-аналитик использует свои знания системы и способность к интерпретации спецификации на предмет того, 
чтобы "предугадать", при каких входных условиях система может выдать ошибку. Например, спецификация 
говорит: "Пользователь должен ввести код". Тест-аналитик, будет думать: "Что, если я не введу код?", "Что, если 
я введу неправильный код? " и так далее. Это и есть предугадывание ошибки.


+СОСТОЯНИЕ ПЕРЕХОДОВ.

Есть объект, который может находиться в разных состояниях. Переход от одного состояния к другому 
обычно чем-то обусловлен, например, каким-нибудь действием над объектом. Эти состояния и действия над объектом нам 
необходимо смоделировать.

Пример из игры- Молокозавод. Строение, которое имеет несколько состояний.

Первое состояние — строения не существует в игре. Оно еще не куплено.
Второе состояние — строительство на игровом поле.
Следующее состояние —стадия открытия.
Четвертое состояние —построено.

Представляем визуально:
Не существует - строится - ожидает открытия - построено 
Какиде действия на это влияют:
Не существует --(купить)-- строится --(1.Ускорить за валюту; 2.Подождать час)-- ожидает открытия --(внести материал)-- построено 

Кроме действий, которые влияют на объект и изменяют его состояние, есть еще действия, которые влияют на 
объект, но не изменяют его состояние. Например, поворот или перемещение здания. Такое действие затрагивает 
сам объект, но не влияет на его состояние. Их также необходимо определить и отобразить.

Далее необходимо перенести нашу модель в таблицу и составить из нее чек-лист проверок. 